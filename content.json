{"meta":{"title":"Grooes.com","subtitle":"The power of expression","description":"The power of expression","author":"qinghe Song","url":"http://grooes.com"},"pages":[{"title":"link","date":"2017-09-17T03:38:42.000Z","updated":"2017-09-17T03:39:33.549Z","comments":true,"path":"link/index.html","link":[{"name":"����������","info":"���������꣬����һ����·��","url":"http://yuyinghua.com/","avatar":"http://yuyinghua.com/icon.png"}],"permalink":"http://grooes.com/link/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-09-17T02:02:50.000Z","updated":"2017-09-17T02:03:03.349Z","comments":false,"path":"categories/index.html","permalink":"http://grooes.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2017-09-17T02:01:14.000Z","updated":"2017-09-17T02:02:01.109Z","comments":false,"path":"tag/index.html","permalink":"http://grooes.com/tag/index.html","excerpt":"","text":""},{"title":"search","date":"2017-09-17T03:54:42.718Z","updated":"2017-09-17T03:54:42.718Z","comments":false,"path":"search/index.html","permalink":"http://grooes.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"Go语言中的 Array, Slice和 Map","slug":"Go语言中的-Array-Slice和-Map","date":"2017-09-17T12:51:23.000Z","updated":"2017-09-17T13:31:38.101Z","comments":true,"path":"2017/09/17/Go语言中的-Array-Slice和-Map/","link":"","permalink":"http://grooes.com/2017/09/17/Go语言中的-Array-Slice和-Map/","excerpt":"","text":"Array, Slice和 Map的区别 Array 是值类型，Slice 和 Map 是引用类型。他们是有很大区别的，尤其是在参数传递的时候。 Slice 和 Map 的变量 仅仅声明是不行的，必须还要分配空间（也就是初始化，initialization） 才可以使用。 Slice 和 Map 这些引用变量 的 内存分配，不需要你操心，因为 golang 是存在 gc 机制的（垃圾回收机制） Array 的用法 数组的声明（这里就是定义，给数据存储分配了空间） 1var arrayName [arraySize] dataType 如果数组定义好之后， 没有给数组元素指定值，那么所有元素被自动初始化为零值 数组的初始化 12345var a = [10]int&#123;1,2,3,4,5,6,7,8,9,10&#125; //定义数组的时候，直接初始化var b = [10]int &#123;1, 2, 3, 4&#125; //部分元素初始化， 其余元素零值var c = [...]int &#123;1, 2, 3, 4, 5&#125; //由初始化列表决定数组长度，不可省去标识符 \"...\"，否则将变成切片Slicevar d = [10]&#123;2:4, 5:7&#125; //可以按照下标来进行初始化 数组的访问，可以直接按照下标进行访问 数组的遍历(for) 12345678910111213141516package mainimport( \"fmt\")func main() &#123; var f = [20]int &#123;1, 1&#125; for i := 2; i &lt; 20; i++ &#123; f[i] = f[i-1] + f[i-2] &#125; for i := 0; i &lt; 20; i++ &#123; //采用下标进行遍历 if i % 5 == 0 &#123; fmt.Printf(\"\\n\") &#125; fmt.Printf(\"f[%2d] = %4d\",i , f[i]) &#125;&#125; 数组的遍历(range) 12345678910111213package mainimport( \"fmt\")func main() &#123; var f = [20]int &#123;1, 1&#125; for i := 2; i &lt; 20; i++ &#123; f[i] = f[i-1] + f[i -2] &#125; for i , v := range f &#123; //采用 range 关键字 进行遍历 fmt.Printf(\"f[%2d] = %4d\", i, v) &#125;&#125; 多维数组 12var a [3][4]intvar b = [3][4]int &#123;&#123;1,2&#125;, &#123;1,2,3,4&#125;, &#123;2,3, 4&#125;&#125; 多维数组遍历 123456789101112131415161718package mainimport \"fmt\"func main() &#123; //找到二维数组中的最大元素 var i, j, row, col, max int var a = [3][4]int &#123;&#123;1, 3, 7, 3&#125;, &#123;2, 3, 7 , 9&#125;, &#123;22, 3, 5, 10&#125;&#125; max = a[0][0] for i := 0; i &lt; = 2; i ++ &#123; for j := 0; j &lt;= 3; j++ &#123; if a[i][j] &gt; max &#123; max = a[i][j] row = i col = j &#125; &#125; &#125; fmt.Println(\"max = %d, row = %d, col = %d\\n\", max, row, col)&#125; Slice 的用法 Slice 的声明（没有分配内存） 1var s1 []int 在创建切片的时候，不要指定切片的长度。（否则就成了数组） 切片的类型可以是Go 语言的任何基本数据类型（也包括 引用类型和 Struct 类型） 当一个切片被声明之后，没有初始化的时候，这个 s1 默认的值是 nil。切片的长度是0。可以使用内建函数 len() 获得切片的长度，使用内建函数 cap() 获得切片的容量。 Slice 的创建 (分配了内存) 三种创建方式： 基于底层数组创建，直接创建，或者 make() 函数创建 基于底层数组创建 slice 123456var slice1 []int //声明但是不分配空间slice1 = array[start:end] //这里不包含 endslice2 := array[:] // 引用全部的元素slice3 := array[0:len(array)]var slice4 []intsliec34 = array //引用全部的元素 直接创建 slice(在声明的时候，直接初始化。) 1var slice1 = []int &#123;1 ,2, 3, 4, 5&#125; make() 函数创建 slice 12var slice1 = make([]int, 5) //长度和容量都是 5var slice2 = make([]int, 5, 10) //容量是5. Slice 的 访问和遍历(采用下标进行访问，采用 range 进行遍历。) 1234567891011121314packge mainimport \"fmt\"func main() &#123; var slice1 = []int &#123;1, 2,3 , 4, 5&#125; //使用下标访问 slice for i := 0; i &lt;=4; i++ &#123; fmt.Println(\"slice[%d] = %d\", i, slice[i]) &#125; fmt.Println() //使用range 进行遍历 for i, v := range slice &#123; fmt.Println(\"slice[%d] = %d\", i, v) &#125; &#125; Slice 的操作 Slice 中的切片的元素，可以动态的添加和删除，所以操作起来要比数组更加方便 采用内建函数 append() 向切片尾部，增加新的元素， 这些元素保存到底层的数组。 append() 并不会影响原来的切片的属性，（原来切片的长度和cap） append() 将会返回更新后的切片的对象。 append() 是个变参函数，可以一次性添加多个对象 append() 添加元素的个数超过 切片的 cap() 的时候，那么底层会 重新分配一个 “足够大” 的内存，一般来说是将原来的内存空间扩大二倍，然后将数据复制到新的内存中去， 原来的空间会保留 （供原先切片使用）（底层数组变化这个问题，应该关注一下） 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; //使用make 创建 切片 var slice1 = make([]int, 3, 6) // 使用 append 添加元素，并且未超出 cap slice2 := append(slice1, 1, 2, 3) // 使用 append 添加元素，并且超出 cap. 这个时候底层数组会变化，新增加的元素只会添加到新的底层数组，不会覆盖旧的底层数组。 slice3 := append(slice1, 4, 5, 6, 7) slice1[0] = 10 fmt.Printf(\"len = %d cap = %d %v\\n\", len(slice1), cap(slice1), slice1) fmt.Printf(\"len = %d cap = %d %v\\n\", len(slice2), cap(slice2), slice2) fmt.Printf(\"len = %d cap = %d %v\\n\", len(slice3), cap(slice3), slice3)&#125;程序输出是：len = 3 cap = 6 [10 0 0]len = 6 cap = 6 [10 0 0 1 2 3] // 这里的[1, 2, 3] 没有被 [4, 5, 6]覆盖len = 7 cap = 12 [0 0 0 4 5 6 7] //这里第一个元素没有变成10，并且容量变成原来的2倍。 切片元素的复制 使用切片长时间引用超大的底层数组，会导致严重的内存浪费现象。 可以新建一个小的slice 对象，然后将所需要的数据复制过去，这样子就不会引用底层数组，直接拷贝了数据，这就是需求。函数 copy()可以 在切片之间复制元素。 copy() 可以复制的元素数量取决于 复制方 和 被复制方的最小长度。 同一个底层数组之间的 元素复制，会导致元素重叠问题。12345678910111213141516171819package mainimport \"fmt\"func main() &#123; var slice1 = []int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; var slice2 = make([]int, 3, 5) var n int n = copy(slice2, slice1) // just copy three elements fmt.Println(n, slice2, len(slice2), cap(slice2)) slice3 := slice1[3:6] //二者引用同一个底层数组 n = copy(slice3, slice1[1:5]) //所以，copy的时候发生元素重叠 fmt.Println(n, slice1, slice3)&#125;程序输出为：3 [1 2 3] 3 53 [1 2 3 2 3 4 7 8 9 10] [2 3 4] //可以看到元素重叠 Map 的用法map 存储的是 键值对(key-value)。是一个无序的数据的集合，通过键来进行索引得到对应的值。 这种方式可以加快查找速度。Map 通常称为 字典（dictionary） 或者哈希表(Hash table)。Map 现在是很多语言的标配。 字典的声明 字典名称，“键”类型， “值”类型 不需要给字典指定长度，字典的长度会在初始化或者创建的过程中动态增长 Key 必须是能支持 比较运算符（==, !=）的数据类型，比如 整数，浮点数，指针，数组，结构体，接口等。 而不能是 函数，字典，切片这些类型。 Value 类型 可以是Go语言的任何基本数据类型。1var mapName map[keyType]valueType 字典的初始化 和 创建 字典 声明好之后，必须经过初始化或者创建 才能使用。未初始化或者创建的字典为 nil 可以使用“{}”来在声明的时候进行初始化 可是使用 make()来创建字典 创建或者初始化之后，就可以使用 “=”操作符来动态的向字典中添加数据项了1234567891011var map1 map[string]int &#123;&#125; //字典的初始化map1[\"key1\"] = 1var map2 map[string]intmap2 = make(map[string]int) //字典的创建map2[\"key2\"] = 2 //使用 等号 添加数据项var map3 map[string]intmap3[\"key1\"] = 2 //编译不通过，字典没有初始化或者创建v, OK := mapName[Key] //元素的查找 注意这里是 := 12345678910111213141516171819202122232425package mainimport \"fmt\"func main() &#123; var map1 = map[string]int&#123;\"key1\": 100, \"key2\": 200&#125; // v, OK := map1[\"key1\"] if OK &#123; fmt.Println(v, OK) &#125; else &#123; fmt.Println(v) &#125; // 这里 不是 :=，是 = ，因为这些变量已经定义过了。 v, OK = map1[\"key3\"] if OK &#123; fmt.Println(v, OK) &#125; else &#123; fmt.Println(v) &#125;&#125;输出为：100 true0 字典项的删除 go 提供了内置函数 delete() 来删除容器内的元素。(如果key1值不存在，那么调用将什么也不发生，也不会产生副作用。 但是，如果传入的map 是一个 nil，那么将导致程序出现异常，这一点在写程序的时候特别注意。)1delete(map1, \"key1\") 12345678910111213141516171819202122232425package mainimport ( \"fmt\")func main() &#123; var map1 = map[string]int&#123;\"key1\": 100, \"key2\": 200, \"key3\": 300&#125; for k, v := range map1 &#123; fmt.Println(k, v) if k == \"key2\" &#123; delete(map1, k) &#125; if k == \"key3\" &#123; map1[\"key4\"] = 400 &#125; &#125; fmt.Println(map1)&#125;程序输出：key2 200key3 300key1 100map[key1:100 key4:400 key3:300] //可以看到 map 是无序的。","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://grooes.com/tags/go/"}]},{"title":"mysql安装那点事儿","slug":"mysql安装那点事儿","date":"2017-09-17T09:02:24.000Z","updated":"2017-09-17T09:03:35.251Z","comments":true,"path":"2017/09/17/mysql安装那点事儿/","link":"","permalink":"http://grooes.com/2017/09/17/mysql安装那点事儿/","excerpt":"","text":"安装mysql rpm -qa | grep mysql // 这个命令就会查看该操作系统上是否已经安装了mysql数据库rpm -e mysql // 普通删除模式rpm -e –nodeps mysql // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除yum list | grep mysql //查看yum上提供的mysql数据库可下载的版本yum install -y mysql-server mysql mysql-deve //下载rpm -qi mysql-server //查看mysql版本service mysqld start //启动mysqlservice mysqld restart //重启mysqlchkconfig –list | grep mysqld //查看mysql服务是不是开机自动启动mysqld 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭chkconfig mysqld on //设置成开机启动，这样就不用每次都去手动启动了/usr/bin/mysqladmin -u root password ‘root’ //设置账号密码mysql -u root -p //进入mysql数据库Enter password: //输入密码即可完毕！ centos6.6安装mysql5.7.17 因用yum安装的是比较古老的mysql版本，所以需要升级最新版本首先查看安装的mysql，需要全部移除rpm -qa | grep mysqlmysql-community-common-5.1.17-1.el6.x86_64mysql-community-libs-5.2.17-1.el6.x86_64mysql-community-server-5.1.17-1.el6.x86_64mysql-community-client-5.1.17-1.el6.x86_64一共四个需要全部删除rpm -e –nodeps mysql-community-common-5.1.17-1.el6.x86_64rpm -e –nodeps mysql-community-libs-5.2.17-1.el6.x86_64rpm -e –nodeps mysql-community-server-5.1.17-1.el6.x86_64rpm -e –nodeps mysql-community-client-5.1.17-1.el6.x86_64rpm -qa | grep mysql确保没有了mysql 进入：https://dev.mysql.com/downloads/file/?id=467446下载到的包：mysql-5.7.17-1.el6.x86_64.rpm-bundle.tarcd /tmprz mysql-5.7.17-1.el6.x86_64.rpm-bundle.tartar -xvf mysql-5.7.17-1.el6.x86_64.rpm-bundle.tarrpm -ivh mysql-community-common-5.7.17-1.el6.x86_64.rpmrpm -ivh mysql-community-libs-5.7.17-1.el6.x86_64.rpmrpm -ivh mysql-community-client-5.7.17-1.el6.x86_64.rpmrpm -ivh mysql-community-server-5.7.17-1.el6.x86_64.rpmchmod 777 -R /var/lib/mysqlservice mysqld startMySQL Daemon failed to start.正在启动 mysqld： [失败]getenforceEnforcingsetenforce 0service mysqld start正在启动 mysqld： [确定]mysqlERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)尼玛，我怎么知道密码？我都没设置密码shell&gt;/usr/bin/mysqld_safe –skip-grant-tables &amp;shell&gt;mysql -u root -p下面的密码直接键入回车即可.mysql&gt;use mysqlmysql&gt;update mysql.user set authentication_string=PASSWORD(‘root’) where user=’root’ and host=’localhost’;mysql&gt;flush privileges;mysql&gt;exit;shell&gt;mysql -u root -p输入密码即可完毕！突然发现在关闭服务器后去启动mysql的时候又启动失败了猜想是getenforce，于是乎执行getenforce竟然成了Enforcing，如果每次启动都这样，岂不是很累，于是乎不能忍google了下，永久解决办法是设置永久性的shell&gt;vi /etc/sysconfig/selinuxSELINUX=disabled 设置成这样既可，打开是知道共有三个值可以选择的done!然后进入shell&gt;mysql -u root -p输入密码后执行mysql&gt;show databases;ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.错误解决办法：mysql&gt;SET PASSWORD= PASSWORD(‘new password’);mysql&gt;ALTER USER ‘root’@’localhost’ PASSWORD EXPIRE NEVER;mysql&gt;flush privileges;mysql&gt;exit;重新登录既可done!","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://grooes.com/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"http://grooes.com/tags/linux/"}]},{"title":"PHP7环境搭建那点事儿","slug":"PHP7环境搭建那点事儿","date":"2017-09-17T01:30:09.000Z","updated":"2017-09-17T02:16:26.950Z","comments":true,"path":"2017/09/17/PHP7环境搭建那点事儿/","link":"","permalink":"http://grooes.com/2017/09/17/PHP7环境搭建那点事儿/","excerpt":"","text":"安装包准备 nginx-1.11.6.tar.gz google-perftools-1.6.tar.gz libevent-2.0.22-stable.tar.gz libiconv-1.13.1.tar.gz libmcrypt-2.5.8.tar.gz libmemcached-1.0.18.tar.gz m9php-php7.tar.gz mcrypt-2.6.8.tar.gz memcache-3.0.8.tgz memcached-1.4.34.tar.gz mhash-0.9.9.9.tar.gz pecl-memcache-php7.tar.gz php-7.0.14.tar.gz php-memcached-master.tar.gz phpredis-develop.tar.gz protobuf-master.tar.gz 环境准备 yum -y install lrzsz（为了运用rz命令把本地包上次上去） yum -y install wget(为了下载包) yum -y install zip unzip(为了解压包) yum -y install gcc(安装gcc) yum -y install openssl openssl-devel(安装openssl) yum -y install pcre*(安装pcre) yum -y install gcc gcc-c++(安装c++) yum -y install libxml2(安装相关libxml2) yum -y install curl(安装curl相关) yum -y install curl-devel(安装curl-devel) yum -y install libpng*(安装libpng相关) 相关环境搭建 安装nginx tar zxf nginx-1.11.6.tar.gzcd nginx-1.11.6./configure –prefix=/usr/local/nginx –user=www –group=www –with-http_stub_status_module –with-http_flv_module –with-http_ssl_modulemake &amp;&amp; make install 启动nginx /usr/local/nginx/sbin/nginx报错：nginx: [emerg] getpwnam(“www”) failed解决方式1：在nginx.conf中 把user nobody的注释去掉既可解决方式2：/usr/sbin/groupadd -f www /usr/sbin/useradd -g www www 本机浏览器输入：http://ip/成功标识：Welcome to nginx!失败标识：考虑关闭防火墙或者打开80端口即可 安装libiconv tar zxf libiconv-1.13.1.tar.gzcd libiconv-1.13.1/./configure –prefix=/usr/local/libiconvmake &amp;&amp; make install 安装libevent tar zxvf libevent-2.0.22-stable.tar.gz cd libevent-2.0.22-stable./configure –prefix=/usr/local/libeventmake &amp;&amp; make test &amp;&amp; make install 安装libmcrypt tar zxf libmcrypt-2.5.8.tar.gzcd libmcrypt-2.5.8/./configuremake &amp;&amp; make install 安装mhash tar zxf mhash-0.9.9.9.tar.gzcd mhash-0.9.9.9./configuremake &amp;&amp; make install 开启软连接 ln -s /usr/local/lib/libmcrypt.la /usr/lib/libmcrypt.laln -s /usr/local/lib/libmcrypt.so /usr/lib/libmcrypt.soln -s /usr/local/lib/libmcrypt.so.4 /usr/lib/libmcrypt.so.4ln -s /usr/local/lib/libmcrypt.so.4.4.8 /usr/lib/libmcrypt.so.4.4.8ln -s /usr/local/lib/libmhash.a /usr/lib/libmhash.aln -s /usr/local/lib/libmhash.la /usr/lib/libmhash.laln -s /usr/local/lib/libmhash.so /usr/lib/libmhash.soln -s /usr/local/lib/libmhash.so.2 /usr/lib/libmhash.so.2ln -s /usr/local/lib/libmhash.so.2.0.1 /usr/lib/libmhash.so.2.0.1ln -s /usr/local/bin/libmcrypt-config /usr/bin/libmcrypt-config 安装memcached tar -zxvf memcached-1.4.34.tar.gzcd memcached-1.4.34./configure –prefix=/usr/local/memcached –with-libevent=/usr/local/libevent/make &amp;&amp; make install启动memcached :/usr/local/memcached/bin/memcached -d -m 100 -u root -l 127.0.0.1 -p 11211 -c 256 -P /tmp/memcached.pid 安装mcrypt tar zvxf mcrypt-2.6.8.tar.gzcd mcrypt-2.6.8./configure报错：configure: error: * libmcrypt was not found （其实我已经安装了libmcrypt）解决：export LD_LIBRARY_PATH=/usr/local/lib: LD_LIBRARY_PATH./configuremake &amp;&amp; make install 安装php7 tar zvxf php-7.0.14.tar.gzcd php-7.0.14./configure –prefix=/usr/local/php –with-config-file-path=/usr/local/php/etc –enable-fpm –enable-pcntl –enable-mysqlnd –enable-opcache –enable-sockets –enable-sysvmsg –enable-sysvsem –enable-sysvshm –enable-shmop –enable-zip –enable-ftp –enable-soap –enable-xml –enable-mbstring –disable-rpath –disable-debug –disable-fileinfo –with-mysqli –with-pdo-mysql –with-pcre-regex –with-iconv –with-zlib –with-mcrypt –with-gd –with-openssl –with-mhash –with-xmlrpc –with-curl –without-pear –enable-fileinfo –with-imap-sslmake &amp;&amp; make installcp ./php.ini-development /usr/local/php/etc/php.inicp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.confcp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.confcp -R ./sapi/fpm/php-fpm /etc/init.d/php-fpm 安装libmemcached tar zxvf libmemcached-1.0.18.tar.gzcd libmemcached-1.0.18./configure –prefix=/usr/local/libmemcached –with-memcachedmake &amp;&amp; make install 安装php-memcached扩展 tar xvzf php-memcached-master.tar.gzcd php-memcached-master/usr/local/php/bin/phpize./configure –enable-memcached –with-php-config=/usr/local/php/bin/php-config –with-libmemcached-dir=/usr/local/libmemcached –disable-memcached-saslmake &amp;&amp; make install查看是否安装成功/usr/local/php/bin/php -m 测试php-memcached扩展 vi /usr/local/php/etc/php.ini添加：extension=memcached.so wq!启动fpm:/usr/local/php/sbin/php-fpm -R验证：ps -ef | grep ‘fpm’启动memcached:/usr/local/memcached/bin/memcached -d -m 100 -u root -l 127.0.0.1 -p 11211 -c 256 -P /tmp/memcached.pid验证：ps -ef | grep ‘memcached’验证是否连接成功vi /tmp/memcached.php输入：12345678910111213&lt;?php $m = new Memcached(); $m-&gt;addServer('127.0.0.1', 11211); $m-&gt;set('int', 99); $m-&gt;set('string', 'a simple string'); $m-&gt;set('array', array(11, 12)); $m-&gt;set('object', new stdclass, time() + 300); var_dump($m-&gt;get('int')); var_dump($m-&gt;get('string')); var_dump($m-&gt;get('array')); var_dump($m-&gt;get('object'));?&gt; wq!cd /tmp执行：/usr/local/php/bin/php memcached.php 打印成功即可 测试php-mysql扩展 vi /tmp/mysql.php1234567&lt;?php $pdo = new PDO(\"mysql:host=hostname;dbname=databasename\",\"root\",\"\"); $rs = $pdo -&gt; query(\"select * from test\"); while($row = $rs -&gt; fetch())&#123; print_r($row); &#125;?&gt; wq!cd /tmp执行：/usr/local/php/bin/php mysql.php 打印成功即可 安装php-redis扩展 tar xvf phpredis-develop.tar.gzcd phpredis-develop/usr/local/php/bin/phpize./configure –with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make installvi /usr/local/php/etc/php.ini输入：extension=redis.sowq!查看是否安装成功/usr/local/php/bin/php -m 安装m9php-php7扩展 tar -zxvf m9php-php7.tar.gzcd m9php/m9php/usr/local/php/bin/phpize./configure –with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make installvi /usr/local/php/etc/php.ini输入：extension=m9php.sowq!查看是否安装成功/usr/local/php/bin/php -m","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://grooes.com/tags/linux/"},{"name":"php","slug":"php","permalink":"http://grooes.com/tags/php/"}]}]}
{"meta":{"title":"Grooes.com","subtitle":"The power of expression","description":"The power of expression","author":"qinghe Song","url":"http://grooes.com"},"pages":[{"title":"link","date":"2017-09-17T03:38:42.000Z","updated":"2017-09-17T03:39:33.549Z","comments":true,"path":"link/index.html","link":[{"name":"����������","info":"���������꣬����һ����·��","url":"http://yuyinghua.com/","avatar":"http://yuyinghua.com/icon.png"}],"permalink":"http://grooes.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-09-19T12:50:17.000Z","updated":"2017-09-20T12:56:22.282Z","comments":true,"path":"tags/index.html","permalink":"http://grooes.com/tags/index.html","excerpt":"","text":"tags: php go algorithm mysql linux interview"},{"title":"categories","date":"2017-09-17T02:02:50.000Z","updated":"2017-09-17T02:03:03.349Z","comments":false,"path":"categories/index.html","permalink":"http://grooes.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2017-09-17T03:54:42.718Z","updated":"2017-09-17T03:54:42.718Z","comments":false,"path":"search/index.html","permalink":"http://grooes.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP中的Traits详解","slug":"PHP中的Traits详解","date":"2017-09-20T13:14:08.000Z","updated":"2017-09-20T13:23:35.157Z","comments":true,"path":"2017/09/20/PHP中的Traits详解/","link":"","permalink":"http://grooes.com/2017/09/20/PHP中的Traits详解/","excerpt":"","text":"原文地址：PHP-Trait特性详解PHP是单继承的语言，在PHP 5.4 Traits出现之前，PHP的类无法同时从两个基类继承属性或方法。php的Traits和Go语言的组合功能类似，通过在类中使用use关键字声明要组合的Trait名称，而具体某个Trait的声明使用trait关键词，Trait不能直接实例化。具体用法请看下面的代码123456789101112131415161718192021222324252627&lt;?php trait Drive &#123; public $carName = 'trait'; public function driving() &#123; echo \"driving &#123;$this-&gt;carName&#125;\\n\"; &#125; &#125; class Person &#123; public function eat() &#123; echo \"eat\\n\"; &#125; &#125; class Student extends Person &#123; use Drive; public function study() &#123; echo \"study\\n\"; &#125; &#125; $student = new Student(); $student-&gt;study(); $student-&gt;eat(); $student-&gt;driving(); //输出结果如下 study eat driving trait 上面的例子中，Student类通过继承Person，有了eat方法，通过组合Drive，有了driving方法和属性carName。 如果Trait、基类和本类中都存在某个同名的属性或者方法，最终会保留哪一个呢？通过下面的代码测试一下：123456789101112131415161718192021222324252627282930&lt;?php trait Drive &#123; public function hello() &#123; echo \"hello drive\\n\"; &#125; public function driving() &#123; echo \"driving from drive\\n\"; &#125; &#125; class Person &#123; public function hello() &#123; echo \"hello person\\n\"; &#125; public function driving() &#123; echo \"driving from person\\n\"; &#125; &#125; class Student extends Person &#123; use Drive; public function hello() &#123; echo \"hello student\\n\"; &#125; &#125; $student = new Student(); $student-&gt;hello(); $student-&gt;driving(); //输出结果如下 hello student driving from drive 因此得出结论：当方法或属性同名时，当前类中的方法会覆盖 trait的 方法，而 trait 的方法又覆盖了基类中的方法。如果要组合多个Trait，通过逗号分隔 Trait名称：1use Trait1, Trait2; 如果多个Trait中包含同名方法或者属性时，会怎样呢？答案是当组合的多个Trait包含同名属性或者方法时，需要明确声明解决冲突，否则会产生一个致命错误。 1234567891011121314151617181920212223&lt;?phptrait Trait1 &#123; public function hello() &#123; echo \"Trait1::hello\\n\"; &#125; public function hi() &#123; echo \"Trait1::hi\\n\"; &#125;&#125;trait Trait2 &#123; public function hello() &#123; echo \"Trait2::hello\\n\"; &#125; public function hi() &#123; echo \"Trait2::hi\\n\"; &#125;&#125;class Class1 &#123; use Trait1, Trait2;&#125;//输出结果如下PHP Fatal error: Trait method hello has not been applied, because there are collisions with other trait methods on Class1 in ~/php54/trait_3.php on line 20 使用insteadof和as操作符来解决冲突，insteadof是使用某个方法替代另一个，而as是给方法取一个别名，具体用法请看代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phptrait Trait1 &#123; public function hello() &#123; echo \"Trait1::hello\\n\"; &#125; public function hi() &#123; echo \"Trait1::hi\\n\"; &#125;&#125;trait Trait2 &#123; public function hello() &#123; echo \"Trait2::hello\\n\"; &#125; public function hi() &#123; echo \"Trait2::hi\\n\"; &#125;&#125;class Class1 &#123; use Trait1, Trait2 &#123; Trait2::hello insteadof Trait1; Trait1::hi insteadof Trait2; &#125;&#125;class Class2 &#123; use Trait1, Trait2 &#123; Trait2::hello insteadof Trait1; Trait1::hi insteadof Trait2; Trait2::hi as hei; Trait1::hello as hehe; &#125;&#125;$Obj1 = new Class1();$Obj1-&gt;hello();$Obj1-&gt;hi();echo \"\\n\";$Obj2 = new Class2();$Obj2-&gt;hello();$Obj2-&gt;hi();$Obj2-&gt;hei();$Obj2-&gt;hehe();//输出结果如下：Trait2::helloTrait1::hiTrait2::helloTrait1::hiTrait2::hiTrait1::hello as关键词还有另外一个用途，那就是修改方法的访问控制：123456789101112131415161718192021&lt;?php trait Hello &#123; public function hello() &#123; echo \"hello,trait\\n\"; &#125; &#125; class Class1 &#123; use Hello &#123; hello as protected; &#125; &#125; class Class2 &#123; use Hello &#123; Hello::hello as private hi; &#125; &#125; $Obj1 = new Class1(); $Obj1-&gt;hello(); # 报致命错误，因为hello方法被修改成受保护的 $Obj2 = new Class2(); $Obj2-&gt;hello(); # 原来的hello方法仍然是公共的 $Obj2-&gt;hi(); # 报致命错误，因为别名hi方法被修改成私有的 Trait 也能组合Trait，Trait中支持抽象方法、静态属性及静态方法，测试代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phptrait Hello &#123; public function sayHello() &#123; echo \"Hello\\n\"; &#125;&#125;trait World &#123; use Hello; public function sayWorld() &#123; echo \"World\\n\"; &#125; abstract public function getWorld(); public function inc() &#123; static $c = 0; $c = $c + 1; echo \"$c\\n\"; &#125; public static function doSomething() &#123; echo \"Doing something\\n\"; &#125;&#125;class HelloWorld &#123; use World; public function getWorld() &#123; return 'get World'; &#125;&#125;$Obj = new HelloWorld();$Obj-&gt;sayHello();$Obj-&gt;sayWorld();echo $Obj-&gt;getWorld() . \"\\n\";HelloWorld::doSomething();$Obj-&gt;inc();$Obj-&gt;inc();//输出结果如下：HelloWorldget WorldDoing something12","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://grooes.com/tags/php/"}]},{"title":"PHP中的浅复制和深复制","slug":"PHP中的浅复制和深复制","date":"2017-09-20T13:03:31.000Z","updated":"2017-09-20T13:04:54.276Z","comments":true,"path":"2017/09/20/PHP中的浅复制和深复制/","link":"","permalink":"http://grooes.com/2017/09/20/PHP中的浅复制和深复制/","excerpt":"","text":"深刻理解PHP中的浅复制和深复制 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php/** * 深复制的原理是A的改变不会影响B的改变 * 浅复制的原理是A的改变会影响B的改变**/class ObjA&#123; public $num = 0; public $objB; //包含的对象 function __construct() &#123; $this-&gt;objB = new ObjB(); &#125; //只有实现了下面方法聚合类 才能实现深复制 /*function __clone() &#123; $this-&gt;objB = clone $this-&gt;objB; &#125;*/&#125;class ObjB&#123; public $num2 = 0;&#125;//原型对象$objA = new ObjA();//复制对象（=复制引用）$objA2 = $objA;$objA2-&gt;num = 2;//随着$objA2-&gt;num的变化 $objA-&gt;num也变化了print_r($objA-&gt;num . '&lt;br/&gt;'); //结果为2print_r($objA2-&gt;num . '&lt;br/&gt;'); //结果为2//复制对象（‘clone’关键字克隆）$objA3 = clone $objA;$objA3-&gt;num = 4;//随着$objA3-&gt;num的变化 $objA-&gt;num没有变化print_r($objA-&gt;num . '&lt;br/&gt;'); //结果为2print_r($objA3-&gt;num . '&lt;br/&gt;'); //结果为4//但是clone的对象（是聚合类）中包含其他对象时所包含的对象（objB）复制的是引用$objA3-&gt;objB-&gt;num2 = 7;print_r($objA3-&gt;objB-&gt;num2 . '&lt;br/&gt;'); //结果是7print_r($objA-&gt;objB-&gt;num2 . '&lt;br/&gt;'); //结果是7","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://grooes.com/tags/php/"}]},{"title":"实现一个base62_encode和base62_decode方法","slug":"实现一个base62-encode和base62-decode方法","date":"2017-09-20T12:33:51.000Z","updated":"2017-09-20T12:35:42.246Z","comments":true,"path":"2017/09/20/实现一个base62-encode和base62-decode方法/","link":"","permalink":"http://grooes.com/2017/09/20/实现一个base62-encode和base62-decode方法/","excerpt":"","text":"实现一个base62_encode()和base62_decode()方法，要求base62_encode(1)=1,base62_encode(61)=z,base62_decode(‘z’)=61;语言不限 1234567891011121314151617181920212223242526272829303132333435&lt;?php//如果有经验的RD，一眼就知道62个字符是0-9A-Za-z，并且在微博推出的短链服务就知道，这是一道通向短链设计的一个必经之路，具体短链服务不懂怎么设计的自行google，这里不做过多解释class Base62&#123; private $string = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"; public function base62_encode($str) &#123; $out = ''; for ($t = floor(log10($str) / log10(62)); $t &gt;= 0; $t--) &#123; $a = floor($str / pow(62, $t)); $out = $out . substr($this-&gt;string, $a, 1); $str = $str - ($a * pow(62, $t)); &#125; return $out; &#125; public function base62_decode($str) &#123; $out = 0; $len = strlen($str) - 1; for ($t = 0; $t &lt;= $len; $t++) &#123; $out = $out + strpos($this-&gt;string, substr($str, $t, 1)) * pow(62, $len - $t); &#125; return substr(sprintf(\"%f\", $out) , 0, -7); &#125;&#125;$object = new Base62();echo $object-&gt;base62_encode(1) . \"&lt;br/&gt;\";echo $object-&gt;base62_encode(61) . \"&lt;br/&gt;\";echo $object-&gt;base62_decode('z') . \"&lt;br/&gt;\"; ?&gt;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://grooes.com/tags/php/"},{"name":"interview","slug":"interview","permalink":"http://grooes.com/tags/interview/"},{"name":"algorithm","slug":"algorithm","permalink":"http://grooes.com/tags/algorithm/"}]},{"title":"go语言实现排序算法","slug":"go语言实现排序算法","date":"2017-09-20T12:01:51.000Z","updated":"2017-09-20T12:03:09.177Z","comments":true,"path":"2017/09/20/go语言实现排序算法/","link":"","permalink":"http://grooes.com/2017/09/20/go语言实现排序算法/","excerpt":"","text":"Go实现相关排序算法 Go实现冒泡排序 1234567891011121314151617181920212223242526272829303132333435package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,3,0&#125; bubbleAsort(arr) bubbleZsort(arr)&#125;//倒序func bubbleAsort(arr []int) &#123; for i :=0; i &lt; len(arr)-1; i++ &#123; for j := i+1; j&lt; len(arr); j++ &#123; if (arr[i] &lt; arr[j]) &#123; arr[i],arr[j] = arr[j],arr[i] &#125; &#125; &#125; fmt.Println(arr)&#125;//正序func bubbleZsort(arr []int) &#123; for i :=0; i &lt; len(arr)-1; i++ &#123; for j := i+1; j&lt; len(arr); j++ &#123; if (arr[i] &gt; arr[j]) &#123; arr[i],arr[j] = arr[j],arr[i] &#125; &#125; &#125; fmt.Println(arr)&#125; Go实现选择排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,3,0&#125; selectAsort(arr) selectZsort(arr)&#125;//倒序func selectAsort(arr []int) &#123; l := len(arr) m := len(arr) - 1 for i := 0; i &lt; m; i++ &#123; k := i for j := i+1; j &lt; l; j++ &#123; if arr[k] &lt; arr[j] &#123; k = j &#125; &#125; if k != i &#123; arr[k],arr[i] = arr[i],arr[k] &#125; &#125; fmt.Println(arr)&#125;//正序func selectZsort(arr []int) &#123; l := len(arr) m := len(arr) - 1 for i := 0; i &lt; m; i++ &#123; k := i for j := i+1; j &lt; l; j++ &#123; if arr[k] &gt; arr[j] &#123; k = j &#125; &#125; if k != i &#123; arr[k],arr[i] = arr[i],arr[k] &#125; &#125; fmt.Println(arr)&#125; Go实现快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,0&#125; quickAsort(arr, 0, len(arr)-1) fmt.Println(arr) quickZsort(arr, 0, len(arr)-1) fmt.Println(arr)&#125;//倒序func quickAsort(arr []int, start, end int) &#123; if (start &lt; end) &#123; i, j := start, end key := arr[(start + end)/2] for i &lt;= j &#123; for arr[i] &gt; key &#123; i++ &#125; for arr[j] &lt; key &#123; j-- &#125; if i &lt;= j &#123; arr[i], arr[j] = arr[j], arr[i] i++ j-- &#125; &#125; if start &lt; j &#123; quickAsort(arr, start, j) &#125; if end &gt; i &#123; quickAsort(arr, i, end) &#125; &#125;&#125;//正序func quickZsort(arr []int, start, end int) &#123; if (start &lt; end) &#123; i, j := start, end key := arr[(start + end)/2] for i &lt;= j &#123; for arr[i] &lt; key &#123; i++ &#125; for arr[j] &gt; key &#123; j-- &#125; if i &lt;= j &#123; arr[i], arr[j] = arr[j], arr[i] i++ j-- &#125; &#125; if start &lt; j &#123; quickZsort(arr, start, j) &#125; if end &gt; i &#123; quickZsort(arr, i, end) &#125; &#125;&#125; Go实现插入排序 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,0&#125; insertSort(arr) fmt.Println(arr)&#125;func insertSort(arr []int) &#123; n := len(arr) if n &lt; 2 &#123; return &#125; for i := 1; i &lt; n; i++ &#123; for j := i; j &gt;0 &amp;&amp; arr[j] &lt; arr[j-1]; j-- &#123; arr[j], arr[j-1] = arr[j-1], arr[j] &#125; &#125;&#125; Go实现希尔排序 12345678910111213141516171819202122232425262728package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,0&#125; shellSort(arr) fmt.Println(arr)&#125;func shellSort(arr []int) &#123; n := len(arr) h := 1 //寻找合适的间隔h for h &lt; n/3 &#123; h = 3*h +1 &#125; for h &gt;= 1 &#123; for i := h; i &lt; n; i++ &#123; for j := i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j-1]; j -= h &#123; arr[j], arr[j-1] = arr[j-1], arr[j] &#125; &#125; h /= 3 &#125;&#125;","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://grooes.com/tags/go/"}]},{"title":"Go语言中的 Array, Slice和 Map","slug":"Go语言中的-Array-Slice和-Map","date":"2017-09-17T12:51:23.000Z","updated":"2017-09-17T13:31:38.101Z","comments":true,"path":"2017/09/17/Go语言中的-Array-Slice和-Map/","link":"","permalink":"http://grooes.com/2017/09/17/Go语言中的-Array-Slice和-Map/","excerpt":"","text":"Array, Slice和 Map的区别 Array 是值类型，Slice 和 Map 是引用类型。他们是有很大区别的，尤其是在参数传递的时候。 Slice 和 Map 的变量 仅仅声明是不行的，必须还要分配空间（也就是初始化，initialization） 才可以使用。 Slice 和 Map 这些引用变量 的 内存分配，不需要你操心，因为 golang 是存在 gc 机制的（垃圾回收机制） Array 的用法 数组的声明（这里就是定义，给数据存储分配了空间） 1var arrayName [arraySize] dataType 如果数组定义好之后， 没有给数组元素指定值，那么所有元素被自动初始化为零值 数组的初始化 12345var a = [10]int&#123;1,2,3,4,5,6,7,8,9,10&#125; //定义数组的时候，直接初始化var b = [10]int &#123;1, 2, 3, 4&#125; //部分元素初始化， 其余元素零值var c = [...]int &#123;1, 2, 3, 4, 5&#125; //由初始化列表决定数组长度，不可省去标识符 \"...\"，否则将变成切片Slicevar d = [10]&#123;2:4, 5:7&#125; //可以按照下标来进行初始化 数组的访问，可以直接按照下标进行访问 数组的遍历(for) 12345678910111213141516package mainimport( \"fmt\")func main() &#123; var f = [20]int &#123;1, 1&#125; for i := 2; i &lt; 20; i++ &#123; f[i] = f[i-1] + f[i-2] &#125; for i := 0; i &lt; 20; i++ &#123; //采用下标进行遍历 if i % 5 == 0 &#123; fmt.Printf(\"\\n\") &#125; fmt.Printf(\"f[%2d] = %4d\",i , f[i]) &#125;&#125; 数组的遍历(range) 12345678910111213package mainimport( \"fmt\")func main() &#123; var f = [20]int &#123;1, 1&#125; for i := 2; i &lt; 20; i++ &#123; f[i] = f[i-1] + f[i -2] &#125; for i , v := range f &#123; //采用 range 关键字 进行遍历 fmt.Printf(\"f[%2d] = %4d\", i, v) &#125;&#125; 多维数组 12var a [3][4]intvar b = [3][4]int &#123;&#123;1,2&#125;, &#123;1,2,3,4&#125;, &#123;2,3, 4&#125;&#125; 多维数组遍历 123456789101112131415161718package mainimport \"fmt\"func main() &#123; //找到二维数组中的最大元素 var i, j, row, col, max int var a = [3][4]int &#123;&#123;1, 3, 7, 3&#125;, &#123;2, 3, 7 , 9&#125;, &#123;22, 3, 5, 10&#125;&#125; max = a[0][0] for i := 0; i &lt; = 2; i ++ &#123; for j := 0; j &lt;= 3; j++ &#123; if a[i][j] &gt; max &#123; max = a[i][j] row = i col = j &#125; &#125; &#125; fmt.Println(\"max = %d, row = %d, col = %d\\n\", max, row, col)&#125; Slice 的用法 Slice 的声明（没有分配内存） 1var s1 []int 在创建切片的时候，不要指定切片的长度。（否则就成了数组） 切片的类型可以是Go 语言的任何基本数据类型（也包括 引用类型和 Struct 类型） 当一个切片被声明之后，没有初始化的时候，这个 s1 默认的值是 nil。切片的长度是0。可以使用内建函数 len() 获得切片的长度，使用内建函数 cap() 获得切片的容量。 Slice 的创建 (分配了内存) 三种创建方式： 基于底层数组创建，直接创建，或者 make() 函数创建 基于底层数组创建 slice 123456var slice1 []int //声明但是不分配空间slice1 = array[start:end] //这里不包含 endslice2 := array[:] // 引用全部的元素slice3 := array[0:len(array)]var slice4 []intsliec34 = array //引用全部的元素 直接创建 slice(在声明的时候，直接初始化。) 1var slice1 = []int &#123;1 ,2, 3, 4, 5&#125; make() 函数创建 slice 12var slice1 = make([]int, 5) //长度和容量都是 5var slice2 = make([]int, 5, 10) //容量是5. Slice 的 访问和遍历(采用下标进行访问，采用 range 进行遍历。) 1234567891011121314packge mainimport \"fmt\"func main() &#123; var slice1 = []int &#123;1, 2,3 , 4, 5&#125; //使用下标访问 slice for i := 0; i &lt;=4; i++ &#123; fmt.Println(\"slice[%d] = %d\", i, slice[i]) &#125; fmt.Println() //使用range 进行遍历 for i, v := range slice &#123; fmt.Println(\"slice[%d] = %d\", i, v) &#125; &#125; Slice 的操作 Slice 中的切片的元素，可以动态的添加和删除，所以操作起来要比数组更加方便 采用内建函数 append() 向切片尾部，增加新的元素， 这些元素保存到底层的数组。 append() 并不会影响原来的切片的属性，（原来切片的长度和cap） append() 将会返回更新后的切片的对象。 append() 是个变参函数，可以一次性添加多个对象 append() 添加元素的个数超过 切片的 cap() 的时候，那么底层会 重新分配一个 “足够大” 的内存，一般来说是将原来的内存空间扩大二倍，然后将数据复制到新的内存中去， 原来的空间会保留 （供原先切片使用）（底层数组变化这个问题，应该关注一下） 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; //使用make 创建 切片 var slice1 = make([]int, 3, 6) // 使用 append 添加元素，并且未超出 cap slice2 := append(slice1, 1, 2, 3) // 使用 append 添加元素，并且超出 cap. 这个时候底层数组会变化，新增加的元素只会添加到新的底层数组，不会覆盖旧的底层数组。 slice3 := append(slice1, 4, 5, 6, 7) slice1[0] = 10 fmt.Printf(\"len = %d cap = %d %v\\n\", len(slice1), cap(slice1), slice1) fmt.Printf(\"len = %d cap = %d %v\\n\", len(slice2), cap(slice2), slice2) fmt.Printf(\"len = %d cap = %d %v\\n\", len(slice3), cap(slice3), slice3)&#125;程序输出是：len = 3 cap = 6 [10 0 0]len = 6 cap = 6 [10 0 0 1 2 3] // 这里的[1, 2, 3] 没有被 [4, 5, 6]覆盖len = 7 cap = 12 [0 0 0 4 5 6 7] //这里第一个元素没有变成10，并且容量变成原来的2倍。 切片元素的复制 使用切片长时间引用超大的底层数组，会导致严重的内存浪费现象。 可以新建一个小的slice 对象，然后将所需要的数据复制过去，这样子就不会引用底层数组，直接拷贝了数据，这就是需求。函数 copy()可以 在切片之间复制元素。 copy() 可以复制的元素数量取决于 复制方 和 被复制方的最小长度。 同一个底层数组之间的 元素复制，会导致元素重叠问题。12345678910111213141516171819package mainimport \"fmt\"func main() &#123; var slice1 = []int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; var slice2 = make([]int, 3, 5) var n int n = copy(slice2, slice1) // just copy three elements fmt.Println(n, slice2, len(slice2), cap(slice2)) slice3 := slice1[3:6] //二者引用同一个底层数组 n = copy(slice3, slice1[1:5]) //所以，copy的时候发生元素重叠 fmt.Println(n, slice1, slice3)&#125;程序输出为：3 [1 2 3] 3 53 [1 2 3 2 3 4 7 8 9 10] [2 3 4] //可以看到元素重叠 Map 的用法map 存储的是 键值对(key-value)。是一个无序的数据的集合，通过键来进行索引得到对应的值。 这种方式可以加快查找速度。Map 通常称为 字典（dictionary） 或者哈希表(Hash table)。Map 现在是很多语言的标配。 字典的声明 字典名称，“键”类型， “值”类型 不需要给字典指定长度，字典的长度会在初始化或者创建的过程中动态增长 Key 必须是能支持 比较运算符（==, !=）的数据类型，比如 整数，浮点数，指针，数组，结构体，接口等。 而不能是 函数，字典，切片这些类型。 Value 类型 可以是Go语言的任何基本数据类型。1var mapName map[keyType]valueType 字典的初始化 和 创建 字典 声明好之后，必须经过初始化或者创建 才能使用。未初始化或者创建的字典为 nil 可以使用“{}”来在声明的时候进行初始化 可是使用 make()来创建字典 创建或者初始化之后，就可以使用 “=”操作符来动态的向字典中添加数据项了1234567891011var map1 map[string]int &#123;&#125; //字典的初始化map1[\"key1\"] = 1var map2 map[string]intmap2 = make(map[string]int) //字典的创建map2[\"key2\"] = 2 //使用 等号 添加数据项var map3 map[string]intmap3[\"key1\"] = 2 //编译不通过，字典没有初始化或者创建v, OK := mapName[Key] //元素的查找 注意这里是 := 12345678910111213141516171819202122232425package mainimport \"fmt\"func main() &#123; var map1 = map[string]int&#123;\"key1\": 100, \"key2\": 200&#125; // v, OK := map1[\"key1\"] if OK &#123; fmt.Println(v, OK) &#125; else &#123; fmt.Println(v) &#125; // 这里 不是 :=，是 = ，因为这些变量已经定义过了。 v, OK = map1[\"key3\"] if OK &#123; fmt.Println(v, OK) &#125; else &#123; fmt.Println(v) &#125;&#125;输出为：100 true0 字典项的删除 go 提供了内置函数 delete() 来删除容器内的元素。(如果key1值不存在，那么调用将什么也不发生，也不会产生副作用。 但是，如果传入的map 是一个 nil，那么将导致程序出现异常，这一点在写程序的时候特别注意。)1delete(map1, \"key1\") 12345678910111213141516171819202122232425package mainimport ( \"fmt\")func main() &#123; var map1 = map[string]int&#123;\"key1\": 100, \"key2\": 200, \"key3\": 300&#125; for k, v := range map1 &#123; fmt.Println(k, v) if k == \"key2\" &#123; delete(map1, k) &#125; if k == \"key3\" &#123; map1[\"key4\"] = 400 &#125; &#125; fmt.Println(map1)&#125;程序输出：key2 200key3 300key1 100map[key1:100 key4:400 key3:300] //可以看到 map 是无序的。","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://grooes.com/tags/go/"}]},{"title":"mysql安装那点事儿","slug":"mysql安装那点事儿","date":"2017-09-17T09:02:24.000Z","updated":"2017-09-17T09:03:35.251Z","comments":true,"path":"2017/09/17/mysql安装那点事儿/","link":"","permalink":"http://grooes.com/2017/09/17/mysql安装那点事儿/","excerpt":"","text":"安装mysql rpm -qa | grep mysql // 这个命令就会查看该操作系统上是否已经安装了mysql数据库rpm -e mysql // 普通删除模式rpm -e –nodeps mysql // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除yum list | grep mysql //查看yum上提供的mysql数据库可下载的版本yum install -y mysql-server mysql mysql-deve //下载rpm -qi mysql-server //查看mysql版本service mysqld start //启动mysqlservice mysqld restart //重启mysqlchkconfig –list | grep mysqld //查看mysql服务是不是开机自动启动mysqld 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭chkconfig mysqld on //设置成开机启动，这样就不用每次都去手动启动了/usr/bin/mysqladmin -u root password ‘root’ //设置账号密码mysql -u root -p //进入mysql数据库Enter password: //输入密码即可完毕！ centos6.6安装mysql5.7.17 因用yum安装的是比较古老的mysql版本，所以需要升级最新版本首先查看安装的mysql，需要全部移除rpm -qa | grep mysqlmysql-community-common-5.1.17-1.el6.x86_64mysql-community-libs-5.2.17-1.el6.x86_64mysql-community-server-5.1.17-1.el6.x86_64mysql-community-client-5.1.17-1.el6.x86_64一共四个需要全部删除rpm -e –nodeps mysql-community-common-5.1.17-1.el6.x86_64rpm -e –nodeps mysql-community-libs-5.2.17-1.el6.x86_64rpm -e –nodeps mysql-community-server-5.1.17-1.el6.x86_64rpm -e –nodeps mysql-community-client-5.1.17-1.el6.x86_64rpm -qa | grep mysql确保没有了mysql 进入：https://dev.mysql.com/downloads/file/?id=467446下载到的包：mysql-5.7.17-1.el6.x86_64.rpm-bundle.tarcd /tmprz mysql-5.7.17-1.el6.x86_64.rpm-bundle.tartar -xvf mysql-5.7.17-1.el6.x86_64.rpm-bundle.tarrpm -ivh mysql-community-common-5.7.17-1.el6.x86_64.rpmrpm -ivh mysql-community-libs-5.7.17-1.el6.x86_64.rpmrpm -ivh mysql-community-client-5.7.17-1.el6.x86_64.rpmrpm -ivh mysql-community-server-5.7.17-1.el6.x86_64.rpmchmod 777 -R /var/lib/mysqlservice mysqld startMySQL Daemon failed to start.正在启动 mysqld： [失败]getenforceEnforcingsetenforce 0service mysqld start正在启动 mysqld： [确定]mysqlERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)尼玛，我怎么知道密码？我都没设置密码shell&gt;/usr/bin/mysqld_safe –skip-grant-tables &amp;shell&gt;mysql -u root -p下面的密码直接键入回车即可.mysql&gt;use mysqlmysql&gt;update mysql.user set authentication_string=PASSWORD(‘root’) where user=’root’ and host=’localhost’;mysql&gt;flush privileges;mysql&gt;exit;shell&gt;mysql -u root -p输入密码即可完毕！突然发现在关闭服务器后去启动mysql的时候又启动失败了猜想是getenforce，于是乎执行getenforce竟然成了Enforcing，如果每次启动都这样，岂不是很累，于是乎不能忍google了下，永久解决办法是设置永久性的shell&gt;vi /etc/sysconfig/selinuxSELINUX=disabled 设置成这样既可，打开是知道共有三个值可以选择的done!然后进入shell&gt;mysql -u root -p输入密码后执行mysql&gt;show databases;ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.错误解决办法：mysql&gt;SET PASSWORD= PASSWORD(‘new password’);mysql&gt;ALTER USER ‘root’@’localhost’ PASSWORD EXPIRE NEVER;mysql&gt;flush privileges;mysql&gt;exit;重新登录既可done!","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://grooes.com/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"http://grooes.com/tags/mysql/"}]},{"title":"PHP7环境搭建那点事儿","slug":"PHP7环境搭建那点事儿","date":"2017-09-17T01:30:09.000Z","updated":"2017-09-17T02:16:26.950Z","comments":true,"path":"2017/09/17/PHP7环境搭建那点事儿/","link":"","permalink":"http://grooes.com/2017/09/17/PHP7环境搭建那点事儿/","excerpt":"","text":"安装包准备 nginx-1.11.6.tar.gz google-perftools-1.6.tar.gz libevent-2.0.22-stable.tar.gz libiconv-1.13.1.tar.gz libmcrypt-2.5.8.tar.gz libmemcached-1.0.18.tar.gz m9php-php7.tar.gz mcrypt-2.6.8.tar.gz memcache-3.0.8.tgz memcached-1.4.34.tar.gz mhash-0.9.9.9.tar.gz pecl-memcache-php7.tar.gz php-7.0.14.tar.gz php-memcached-master.tar.gz phpredis-develop.tar.gz protobuf-master.tar.gz 环境准备 yum -y install lrzsz（为了运用rz命令把本地包上次上去） yum -y install wget(为了下载包) yum -y install zip unzip(为了解压包) yum -y install gcc(安装gcc) yum -y install openssl openssl-devel(安装openssl) yum -y install pcre*(安装pcre) yum -y install gcc gcc-c++(安装c++) yum -y install libxml2(安装相关libxml2) yum -y install curl(安装curl相关) yum -y install curl-devel(安装curl-devel) yum -y install libpng*(安装libpng相关) 相关环境搭建 安装nginx tar zxf nginx-1.11.6.tar.gzcd nginx-1.11.6./configure –prefix=/usr/local/nginx –user=www –group=www –with-http_stub_status_module –with-http_flv_module –with-http_ssl_modulemake &amp;&amp; make install 启动nginx /usr/local/nginx/sbin/nginx报错：nginx: [emerg] getpwnam(“www”) failed解决方式1：在nginx.conf中 把user nobody的注释去掉既可解决方式2：/usr/sbin/groupadd -f www /usr/sbin/useradd -g www www 本机浏览器输入：http://ip/成功标识：Welcome to nginx!失败标识：考虑关闭防火墙或者打开80端口即可 安装libiconv tar zxf libiconv-1.13.1.tar.gzcd libiconv-1.13.1/./configure –prefix=/usr/local/libiconvmake &amp;&amp; make install 安装libevent tar zxvf libevent-2.0.22-stable.tar.gz cd libevent-2.0.22-stable./configure –prefix=/usr/local/libeventmake &amp;&amp; make test &amp;&amp; make install 安装libmcrypt tar zxf libmcrypt-2.5.8.tar.gzcd libmcrypt-2.5.8/./configuremake &amp;&amp; make install 安装mhash tar zxf mhash-0.9.9.9.tar.gzcd mhash-0.9.9.9./configuremake &amp;&amp; make install 开启软连接 ln -s /usr/local/lib/libmcrypt.la /usr/lib/libmcrypt.laln -s /usr/local/lib/libmcrypt.so /usr/lib/libmcrypt.soln -s /usr/local/lib/libmcrypt.so.4 /usr/lib/libmcrypt.so.4ln -s /usr/local/lib/libmcrypt.so.4.4.8 /usr/lib/libmcrypt.so.4.4.8ln -s /usr/local/lib/libmhash.a /usr/lib/libmhash.aln -s /usr/local/lib/libmhash.la /usr/lib/libmhash.laln -s /usr/local/lib/libmhash.so /usr/lib/libmhash.soln -s /usr/local/lib/libmhash.so.2 /usr/lib/libmhash.so.2ln -s /usr/local/lib/libmhash.so.2.0.1 /usr/lib/libmhash.so.2.0.1ln -s /usr/local/bin/libmcrypt-config /usr/bin/libmcrypt-config 安装memcached tar -zxvf memcached-1.4.34.tar.gzcd memcached-1.4.34./configure –prefix=/usr/local/memcached –with-libevent=/usr/local/libevent/make &amp;&amp; make install启动memcached :/usr/local/memcached/bin/memcached -d -m 100 -u root -l 127.0.0.1 -p 11211 -c 256 -P /tmp/memcached.pid 安装mcrypt tar zvxf mcrypt-2.6.8.tar.gzcd mcrypt-2.6.8./configure报错：configure: error: * libmcrypt was not found （其实我已经安装了libmcrypt）解决：export LD_LIBRARY_PATH=/usr/local/lib: LD_LIBRARY_PATH./configuremake &amp;&amp; make install 安装php7 tar zvxf php-7.0.14.tar.gzcd php-7.0.14./configure –prefix=/usr/local/php –with-config-file-path=/usr/local/php/etc –enable-fpm –enable-pcntl –enable-mysqlnd –enable-opcache –enable-sockets –enable-sysvmsg –enable-sysvsem –enable-sysvshm –enable-shmop –enable-zip –enable-ftp –enable-soap –enable-xml –enable-mbstring –disable-rpath –disable-debug –disable-fileinfo –with-mysqli –with-pdo-mysql –with-pcre-regex –with-iconv –with-zlib –with-mcrypt –with-gd –with-openssl –with-mhash –with-xmlrpc –with-curl –without-pear –enable-fileinfo –with-imap-sslmake &amp;&amp; make installcp ./php.ini-development /usr/local/php/etc/php.inicp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.confcp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.confcp -R ./sapi/fpm/php-fpm /etc/init.d/php-fpm 安装libmemcached tar zxvf libmemcached-1.0.18.tar.gzcd libmemcached-1.0.18./configure –prefix=/usr/local/libmemcached –with-memcachedmake &amp;&amp; make install 安装php-memcached扩展 tar xvzf php-memcached-master.tar.gzcd php-memcached-master/usr/local/php/bin/phpize./configure –enable-memcached –with-php-config=/usr/local/php/bin/php-config –with-libmemcached-dir=/usr/local/libmemcached –disable-memcached-saslmake &amp;&amp; make install查看是否安装成功/usr/local/php/bin/php -m 测试php-memcached扩展 vi /usr/local/php/etc/php.ini添加：extension=memcached.so wq!启动fpm:/usr/local/php/sbin/php-fpm -R验证：ps -ef | grep ‘fpm’启动memcached:/usr/local/memcached/bin/memcached -d -m 100 -u root -l 127.0.0.1 -p 11211 -c 256 -P /tmp/memcached.pid验证：ps -ef | grep ‘memcached’验证是否连接成功vi /tmp/memcached.php输入：12345678910111213&lt;?php $m = new Memcached(); $m-&gt;addServer('127.0.0.1', 11211); $m-&gt;set('int', 99); $m-&gt;set('string', 'a simple string'); $m-&gt;set('array', array(11, 12)); $m-&gt;set('object', new stdclass, time() + 300); var_dump($m-&gt;get('int')); var_dump($m-&gt;get('string')); var_dump($m-&gt;get('array')); var_dump($m-&gt;get('object'));?&gt; wq!cd /tmp执行：/usr/local/php/bin/php memcached.php 打印成功即可 测试php-mysql扩展 vi /tmp/mysql.php1234567&lt;?php $pdo = new PDO(\"mysql:host=hostname;dbname=databasename\",\"root\",\"\"); $rs = $pdo -&gt; query(\"select * from test\"); while($row = $rs -&gt; fetch())&#123; print_r($row); &#125;?&gt; wq!cd /tmp执行：/usr/local/php/bin/php mysql.php 打印成功即可 安装php-redis扩展 tar xvf phpredis-develop.tar.gzcd phpredis-develop/usr/local/php/bin/phpize./configure –with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make installvi /usr/local/php/etc/php.ini输入：extension=redis.sowq!查看是否安装成功/usr/local/php/bin/php -m 安装m9php-php7扩展 tar -zxvf m9php-php7.tar.gzcd m9php/m9php/usr/local/php/bin/phpize./configure –with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make installvi /usr/local/php/etc/php.ini输入：extension=m9php.sowq!查看是否安装成功/usr/local/php/bin/php -m","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://grooes.com/tags/php/"},{"name":"linux","slug":"linux","permalink":"http://grooes.com/tags/linux/"}]}]}
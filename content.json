{"meta":{"title":"Grooes.com","subtitle":"The power of expression","description":"The power of expression","author":"qinghe Song","url":"http://grooes.com"},"pages":[{"title":"categories","date":"2017-09-17T02:02:50.000Z","updated":"2017-09-17T02:03:03.349Z","comments":false,"path":"categories/index.html","permalink":"http://grooes.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2017-09-17T03:54:42.718Z","updated":"2017-09-17T03:54:42.718Z","comments":false,"path":"search/index.html","permalink":"http://grooes.com/search/index.html","excerpt":"","text":""},{"title":"link","date":"2017-09-17T03:38:42.000Z","updated":"2017-09-17T03:39:33.549Z","comments":true,"path":"link/index.html","link":[{"name":"����������","info":"���������꣬����һ����·��","url":"http://yuyinghua.com/","avatar":"http://yuyinghua.com/icon.png"}],"permalink":"http://grooes.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-09-19T12:50:17.000Z","updated":"2017-09-20T12:56:22.282Z","comments":true,"path":"tags/index.html","permalink":"http://grooes.com/tags/index.html","excerpt":"","text":"tags: php go algorithm mysql linux interview"}],"posts":[{"title":"redis之数据结构篇","slug":"redis之数据结构篇","date":"2017-09-23T08:33:59.000Z","updated":"2017-09-23T13:21:34.642Z","comments":true,"path":"2017/09/23/redis之数据结构篇/","link":"","permalink":"http://grooes.com/2017/09/23/redis之数据结构篇/","excerpt":"","text":"redis设计与实现之数据结构篇简单动态字符串(sds) 从数据结构看sds为buf分配了5个字符和0个free空间，\\0是不计算在len内，但是会分配额外的1字节空间，下面讲讲这样设计的好处 数据结构中存了len字段，可以O(1)常数时间获取字符串长度 每次插入元素前都会检查sds空间是否足够，若不满足做适当的扩充，可以避免缓冲区溢出的可能性(C语言中每次插入或者删除字符的时候都要重新分配新的内存来保存新值，是一个很耗时的操作 ) sds采用空间预分配和惰性空间释放两种策略减少了内存重分配的次数，看到free字段就知道这是一个额外的空间来在某种程度上减少了重分配的次数，具体如下 123如现有空间足够存放修改后内容，则不进行扩展，直接插入。如现有空间不足以存放修改后内容，且修改后sds的len小于1M，则扩展后len=free，比如修改后空间为15 byte，则分配的空间是31：15+15+1byte.如现有空间不足以存放修改后内容，且修改后sds的len大于1M，则分配1M的使用空间，则新的空间为20M+1M+1byte 惰性空间释放:用于优化SDS缩减操作.当api对sds进行缩短操作后,程序不会释放缩短后空余出的空间,而是使用free属性把他们记录下来,当我们插入的时候就可以减少内存重分配了(不需要担心，我们以后不添加内容时，造成的内存泄露，因为sds提供了释放空间的API) 二进制安全，不像C语言，C字符串的字符必须某种编码(比如ASCII),并且除末尾外,其余地方不能出现空字符串\\0,否则会被提前结束,(\\0是c字符串的结束标识符),比如acvf\\0sdsdsd\\0,只能识别到acvf，而sds是根据len属性来判断字符串的结束，所以不存在是否有\\0 由于SDS的buf数组以\\0结尾,符合c字符串特征,因此,它可以使用C字符串的一些api 链表 1234567891011121314struct listNode&#123; struct listNode *prev//前置节点 struct listNode *next//后置节点 void *value //节点值&#125;listNode;struct list&#123; listNode *head;//表头节点 listNode *tail;//表尾节点 unsigned long len;//常数时间获取链表长度 void *(*dup)(void *ptr);//节点值复制函数 void *(*free)(void *ptr);//节点值释放函数 void *(*match)(void *ptr,void *key);//节点值对比函数&#125;list; 链表的实现特性总结如下 双端：每个节点都有prev和next，获取某个节点的前置节点和后置节点的复杂度都是O(1) 无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点 带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值 字典字典又称为符号表、关联数组、映射，是一种用于保存键值对的抽象数据结构，下面看某结构实现 哈希表实现12345678910111213141516typedef struct dictht &#123; dictEntry **table;//哈希表数组 unsigned long size;//哈希表大小 unsigned long sizemask;//哈希表大小掩码，用于计算索引值，总是等于 size - 1 unsigned long used;//该哈希表已有节点的数量&#125; dictht;typedef struct dictEntry &#123; void *key;//键 union &#123; void *val; uint64_t u64; int64_t s64; &#125; v;//值 struct dictEntry *next;//指向下个哈希表节点，形成链表&#125; dictEntry; 字典123456789101112131415typedef struct dict &#123; dictType *type;// 类型特定函数，指向 dictType 结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis 会为用途不同的字典设置不同的类型特定函数。 void *privdata;//私有数据，保存了需要传给那些类型特定函数的可选参数 dictht ht[2];//哈希表，是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表， 一般情况下， 字典只使用ht[0]哈希表， ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用 int rehashidx; //rehash索引，当rehash不在进行时，值为-1&#125; dict;typedef struct dictType &#123; unsigned int (*hashFunction)(const void *key);//计算哈希值的函数 void *(*keyDup)(void *privdata, const void *key);//复制键的函数 void *(*valDup)(void *privdata, const void *obj);//复制值的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2);//对比键的函数 void (*keyDestructor)(void *privdata, void *key);//销毁键的函数 void (*valDestructor)(void *privdata, void *obj);//销毁值的函数&#125; dictType; 下图展示一个没有进行rehash的字典 哈希算法当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面，Redis 计算哈希值和索引值的方法如下12345//使用字典设置的哈希函数，计算键 key 的哈希值hash = dict-&gt;type-&gt;hashFunction(key);//使用哈希表的 sizemask 属性和哈希值，计算出索引值，根据情况不同，ht[x] 可以是 ht[0] 或者 ht[1]index = hash &amp; dict-&gt;ht[x].sizemask; 下面是一个空字典的结构图 如上图，如果我们要将一个键值对 k0 和 v0 添加到字典里面， 那么程序会先使用语句12hash = dict-&gt;type-&gt;hashFunction(k0);//计算键 k0 的哈希值，假设计算得出的哈希值为8index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;//计算出键k0的索引值0，这表示包含键值对k0和v0的节点应该被放置到哈希表数组的索引0位置上 解决键冲突当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision），Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题，如图 k1和k2键冲突的话，直接用单向链表连接起来，并且最新添加的放在表头（原因：dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面） rehash随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩， Redis 对字典的哈希表执行 rehash 的步骤如下 为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值） 12如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上 当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备 哈希表的扩展与收缩，当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作1234服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作load_factor = ht[0].used / ht[0].size;//负载因子 = 哈希表已保存节点数量 / 哈希表大小 根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存 渐进式rehashrehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的，原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务，所以哈希表渐进式 rehash 的详细步骤1234为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成 渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找，另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表 跳跃表跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的，支持O(logN)，最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点，另外可以和平衡树相媲美，且实现起来更简单，redis中只有 实现有序集合键、集群节点用作内部数据结构 来个地方，再没有其他用途 跳跃表的实现 位于图最左为zskiplist结构 header ：指向跳跃表的表头节点 tail ：指向跳跃表的表尾节点 level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内） length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内） 位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性 层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行 后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用 分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列 成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象 跳跃表节点1234567891011121314151617typedef struct zskiplistNode &#123; struct zskiplistNode *backward;//后退指针 double score;//分值 robj *obj;//成员对象 struct zskiplistLevel &#123; struct zskiplistNode *forward;//前进指针 unsigned int span;//跨度 &#125; level[];//层&#125; zskiplistNode;typedef struct zskiplist &#123; struct zskiplistNode *header, *tail;//表头节点和表尾节点，header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) unsigned long length;//表中节点的数量，通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度 int level;//表中层数最大的节点的层数，level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内&#125; zskiplist; 跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点层的跨度（level[i].span 属性）用于记录两个节点之间的距离 两个节点之间的跨度越大， 它们相距得就越远 指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点 节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值为啥 redis 使用跳表(skiplist)而不是使用 red-black？ 整数集合整数集合的实现整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，redis就会使用此结构实现，用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素12345typedef struct intset &#123; uint32_t encoding;//编码方式 uint32_t length;//集合包含的元素数量 int8_t contents[];//保存元素的数组，整数集合的底层实现，整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项&#125; intset; 对于encoding，有如下解释 如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ） 如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ） 如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ） 如上图，展示了另一个整数集合示例 encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值 length 属性的值为 5 ， 表示整数集合包含五个元素 contents 数组按从小到大的顺序保存着集合中的五个元素 因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) 5 = 16 5 = 80 位升级每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面，升级整数集合并添加新元素共分为三步进行 根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变 将新元素添加到底层数组里面 升级之后新元素的摆放位置，因为引发升级的新元素的长度总是比整数集合现有的所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素 在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头(index=0) 在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾(index=length-1) 降级整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态 压缩列表压缩列表(ziplist)是列表键和哈希键的底层实现之一，当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，redis就会使用压缩列表来做列表键的底层实现 压缩列表的构成压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构结构如下图 压缩列表节点的构成每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种 长度小于等于 63 （2^{6}-1）字节的字节数组 长度小于等于 16383 （2^{14}-1） 字节的字节数组 长度小于等于 4294967295 （2^{32}-1）字节的字节数组 而整数值则可以是以下六种长度的其中一种 4 位长，介于 0 至 12 之间的无符号整数 1 字节长的有符号整数 3 字节长的有符号整数 int16_t 类型整数 int32_t 类型整数 int64_t 类型整数 每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成 节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度 123如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 previous_entry_length 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点 节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度 12一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录 节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定 连锁更新考虑一种情况就是，一个列表里全是介于某个临界值的且连续多个的节点，如果在表头插入一个大于这个节点的值，那么节点中的previous_entry_length就会发生大批量的更改来达到效果，同理，小于这个临界值也会发生同样的效果，这就叫连锁更新，因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2)要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的 以上原因， ziplistPush 等命令的平均复杂度仅为 O(N) ， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能 至此redis的数据结构就已经完事儿了，接下来会复习redis中的二进制位数组（据我了解这个bit是一个很有实用场景的东西，尤其在节约内存方面）","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://grooes.com/tags/redis/"}]},{"title":"PHP中的Traits详解","slug":"PHP中的Traits详解","date":"2017-09-20T13:14:08.000Z","updated":"2017-09-20T13:23:35.157Z","comments":true,"path":"2017/09/20/PHP中的Traits详解/","link":"","permalink":"http://grooes.com/2017/09/20/PHP中的Traits详解/","excerpt":"","text":"原文地址：PHP-Trait特性详解PHP是单继承的语言，在PHP 5.4 Traits出现之前，PHP的类无法同时从两个基类继承属性或方法。php的Traits和Go语言的组合功能类似，通过在类中使用use关键字声明要组合的Trait名称，而具体某个Trait的声明使用trait关键词，Trait不能直接实例化。具体用法请看下面的代码123456789101112131415161718192021222324252627&lt;?php trait Drive &#123; public $carName = 'trait'; public function driving() &#123; echo \"driving &#123;$this-&gt;carName&#125;\\n\"; &#125; &#125; class Person &#123; public function eat() &#123; echo \"eat\\n\"; &#125; &#125; class Student extends Person &#123; use Drive; public function study() &#123; echo \"study\\n\"; &#125; &#125; $student = new Student(); $student-&gt;study(); $student-&gt;eat(); $student-&gt;driving(); //输出结果如下 study eat driving trait 上面的例子中，Student类通过继承Person，有了eat方法，通过组合Drive，有了driving方法和属性carName。 如果Trait、基类和本类中都存在某个同名的属性或者方法，最终会保留哪一个呢？通过下面的代码测试一下：123456789101112131415161718192021222324252627282930&lt;?php trait Drive &#123; public function hello() &#123; echo \"hello drive\\n\"; &#125; public function driving() &#123; echo \"driving from drive\\n\"; &#125; &#125; class Person &#123; public function hello() &#123; echo \"hello person\\n\"; &#125; public function driving() &#123; echo \"driving from person\\n\"; &#125; &#125; class Student extends Person &#123; use Drive; public function hello() &#123; echo \"hello student\\n\"; &#125; &#125; $student = new Student(); $student-&gt;hello(); $student-&gt;driving(); //输出结果如下 hello student driving from drive 因此得出结论：当方法或属性同名时，当前类中的方法会覆盖 trait的 方法，而 trait 的方法又覆盖了基类中的方法。如果要组合多个Trait，通过逗号分隔 Trait名称：1use Trait1, Trait2; 如果多个Trait中包含同名方法或者属性时，会怎样呢？答案是当组合的多个Trait包含同名属性或者方法时，需要明确声明解决冲突，否则会产生一个致命错误。 1234567891011121314151617181920212223&lt;?phptrait Trait1 &#123; public function hello() &#123; echo \"Trait1::hello\\n\"; &#125; public function hi() &#123; echo \"Trait1::hi\\n\"; &#125;&#125;trait Trait2 &#123; public function hello() &#123; echo \"Trait2::hello\\n\"; &#125; public function hi() &#123; echo \"Trait2::hi\\n\"; &#125;&#125;class Class1 &#123; use Trait1, Trait2;&#125;//输出结果如下PHP Fatal error: Trait method hello has not been applied, because there are collisions with other trait methods on Class1 in ~/php54/trait_3.php on line 20 使用insteadof和as操作符来解决冲突，insteadof是使用某个方法替代另一个，而as是给方法取一个别名，具体用法请看代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phptrait Trait1 &#123; public function hello() &#123; echo \"Trait1::hello\\n\"; &#125; public function hi() &#123; echo \"Trait1::hi\\n\"; &#125;&#125;trait Trait2 &#123; public function hello() &#123; echo \"Trait2::hello\\n\"; &#125; public function hi() &#123; echo \"Trait2::hi\\n\"; &#125;&#125;class Class1 &#123; use Trait1, Trait2 &#123; Trait2::hello insteadof Trait1; Trait1::hi insteadof Trait2; &#125;&#125;class Class2 &#123; use Trait1, Trait2 &#123; Trait2::hello insteadof Trait1; Trait1::hi insteadof Trait2; Trait2::hi as hei; Trait1::hello as hehe; &#125;&#125;$Obj1 = new Class1();$Obj1-&gt;hello();$Obj1-&gt;hi();echo \"\\n\";$Obj2 = new Class2();$Obj2-&gt;hello();$Obj2-&gt;hi();$Obj2-&gt;hei();$Obj2-&gt;hehe();//输出结果如下：Trait2::helloTrait1::hiTrait2::helloTrait1::hiTrait2::hiTrait1::hello as关键词还有另外一个用途，那就是修改方法的访问控制：123456789101112131415161718192021&lt;?php trait Hello &#123; public function hello() &#123; echo \"hello,trait\\n\"; &#125; &#125; class Class1 &#123; use Hello &#123; hello as protected; &#125; &#125; class Class2 &#123; use Hello &#123; Hello::hello as private hi; &#125; &#125; $Obj1 = new Class1(); $Obj1-&gt;hello(); # 报致命错误，因为hello方法被修改成受保护的 $Obj2 = new Class2(); $Obj2-&gt;hello(); # 原来的hello方法仍然是公共的 $Obj2-&gt;hi(); # 报致命错误，因为别名hi方法被修改成私有的 Trait 也能组合Trait，Trait中支持抽象方法、静态属性及静态方法，测试代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phptrait Hello &#123; public function sayHello() &#123; echo \"Hello\\n\"; &#125;&#125;trait World &#123; use Hello; public function sayWorld() &#123; echo \"World\\n\"; &#125; abstract public function getWorld(); public function inc() &#123; static $c = 0; $c = $c + 1; echo \"$c\\n\"; &#125; public static function doSomething() &#123; echo \"Doing something\\n\"; &#125;&#125;class HelloWorld &#123; use World; public function getWorld() &#123; return 'get World'; &#125;&#125;$Obj = new HelloWorld();$Obj-&gt;sayHello();$Obj-&gt;sayWorld();echo $Obj-&gt;getWorld() . \"\\n\";HelloWorld::doSomething();$Obj-&gt;inc();$Obj-&gt;inc();//输出结果如下：HelloWorldget WorldDoing something12","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://grooes.com/tags/php/"}]},{"title":"PHP中的浅复制和深复制","slug":"PHP中的浅复制和深复制","date":"2017-09-20T13:03:31.000Z","updated":"2017-09-20T13:04:54.276Z","comments":true,"path":"2017/09/20/PHP中的浅复制和深复制/","link":"","permalink":"http://grooes.com/2017/09/20/PHP中的浅复制和深复制/","excerpt":"","text":"深刻理解PHP中的浅复制和深复制 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php/** * 深复制的原理是A的改变不会影响B的改变 * 浅复制的原理是A的改变会影响B的改变**/class ObjA&#123; public $num = 0; public $objB; //包含的对象 function __construct() &#123; $this-&gt;objB = new ObjB(); &#125; //只有实现了下面方法聚合类 才能实现深复制 /*function __clone() &#123; $this-&gt;objB = clone $this-&gt;objB; &#125;*/&#125;class ObjB&#123; public $num2 = 0;&#125;//原型对象$objA = new ObjA();//复制对象（=复制引用）$objA2 = $objA;$objA2-&gt;num = 2;//随着$objA2-&gt;num的变化 $objA-&gt;num也变化了print_r($objA-&gt;num . '&lt;br/&gt;'); //结果为2print_r($objA2-&gt;num . '&lt;br/&gt;'); //结果为2//复制对象（‘clone’关键字克隆）$objA3 = clone $objA;$objA3-&gt;num = 4;//随着$objA3-&gt;num的变化 $objA-&gt;num没有变化print_r($objA-&gt;num . '&lt;br/&gt;'); //结果为2print_r($objA3-&gt;num . '&lt;br/&gt;'); //结果为4//但是clone的对象（是聚合类）中包含其他对象时所包含的对象（objB）复制的是引用$objA3-&gt;objB-&gt;num2 = 7;print_r($objA3-&gt;objB-&gt;num2 . '&lt;br/&gt;'); //结果是7print_r($objA-&gt;objB-&gt;num2 . '&lt;br/&gt;'); //结果是7","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://grooes.com/tags/php/"}]},{"title":"实现一个base62_encode和base62_decode方法","slug":"实现一个base62-encode和base62-decode方法","date":"2017-09-20T12:33:51.000Z","updated":"2017-09-20T12:35:42.246Z","comments":true,"path":"2017/09/20/实现一个base62-encode和base62-decode方法/","link":"","permalink":"http://grooes.com/2017/09/20/实现一个base62-encode和base62-decode方法/","excerpt":"","text":"实现一个base62_encode()和base62_decode()方法，要求base62_encode(1)=1,base62_encode(61)=z,base62_decode(‘z’)=61;语言不限 1234567891011121314151617181920212223242526272829303132333435&lt;?php//如果有经验的RD，一眼就知道62个字符是0-9A-Za-z，并且在微博推出的短链服务就知道，这是一道通向短链设计的一个必经之路，具体短链服务不懂怎么设计的自行google，这里不做过多解释class Base62&#123; private $string = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"; public function base62_encode($str) &#123; $out = ''; for ($t = floor(log10($str) / log10(62)); $t &gt;= 0; $t--) &#123; $a = floor($str / pow(62, $t)); $out = $out . substr($this-&gt;string, $a, 1); $str = $str - ($a * pow(62, $t)); &#125; return $out; &#125; public function base62_decode($str) &#123; $out = 0; $len = strlen($str) - 1; for ($t = 0; $t &lt;= $len; $t++) &#123; $out = $out + strpos($this-&gt;string, substr($str, $t, 1)) * pow(62, $len - $t); &#125; return substr(sprintf(\"%f\", $out) , 0, -7); &#125;&#125;$object = new Base62();echo $object-&gt;base62_encode(1) . \"&lt;br/&gt;\";echo $object-&gt;base62_encode(61) . \"&lt;br/&gt;\";echo $object-&gt;base62_decode('z') . \"&lt;br/&gt;\"; ?&gt;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://grooes.com/tags/php/"},{"name":"interview","slug":"interview","permalink":"http://grooes.com/tags/interview/"},{"name":"algorithm","slug":"algorithm","permalink":"http://grooes.com/tags/algorithm/"}]},{"title":"go语言实现排序算法","slug":"go语言实现排序算法","date":"2017-09-20T12:01:51.000Z","updated":"2017-09-20T12:03:09.177Z","comments":true,"path":"2017/09/20/go语言实现排序算法/","link":"","permalink":"http://grooes.com/2017/09/20/go语言实现排序算法/","excerpt":"","text":"Go实现相关排序算法 Go实现冒泡排序 1234567891011121314151617181920212223242526272829303132333435package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,3,0&#125; bubbleAsort(arr) bubbleZsort(arr)&#125;//倒序func bubbleAsort(arr []int) &#123; for i :=0; i &lt; len(arr)-1; i++ &#123; for j := i+1; j&lt; len(arr); j++ &#123; if (arr[i] &lt; arr[j]) &#123; arr[i],arr[j] = arr[j],arr[i] &#125; &#125; &#125; fmt.Println(arr)&#125;//正序func bubbleZsort(arr []int) &#123; for i :=0; i &lt; len(arr)-1; i++ &#123; for j := i+1; j&lt; len(arr); j++ &#123; if (arr[i] &gt; arr[j]) &#123; arr[i],arr[j] = arr[j],arr[i] &#125; &#125; &#125; fmt.Println(arr)&#125; Go实现选择排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,3,0&#125; selectAsort(arr) selectZsort(arr)&#125;//倒序func selectAsort(arr []int) &#123; l := len(arr) m := len(arr) - 1 for i := 0; i &lt; m; i++ &#123; k := i for j := i+1; j &lt; l; j++ &#123; if arr[k] &lt; arr[j] &#123; k = j &#125; &#125; if k != i &#123; arr[k],arr[i] = arr[i],arr[k] &#125; &#125; fmt.Println(arr)&#125;//正序func selectZsort(arr []int) &#123; l := len(arr) m := len(arr) - 1 for i := 0; i &lt; m; i++ &#123; k := i for j := i+1; j &lt; l; j++ &#123; if arr[k] &gt; arr[j] &#123; k = j &#125; &#125; if k != i &#123; arr[k],arr[i] = arr[i],arr[k] &#125; &#125; fmt.Println(arr)&#125; Go实现快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,0&#125; quickAsort(arr, 0, len(arr)-1) fmt.Println(arr) quickZsort(arr, 0, len(arr)-1) fmt.Println(arr)&#125;//倒序func quickAsort(arr []int, start, end int) &#123; if (start &lt; end) &#123; i, j := start, end key := arr[(start + end)/2] for i &lt;= j &#123; for arr[i] &gt; key &#123; i++ &#125; for arr[j] &lt; key &#123; j-- &#125; if i &lt;= j &#123; arr[i], arr[j] = arr[j], arr[i] i++ j-- &#125; &#125; if start &lt; j &#123; quickAsort(arr, start, j) &#125; if end &gt; i &#123; quickAsort(arr, i, end) &#125; &#125;&#125;//正序func quickZsort(arr []int, start, end int) &#123; if (start &lt; end) &#123; i, j := start, end key := arr[(start + end)/2] for i &lt;= j &#123; for arr[i] &lt; key &#123; i++ &#125; for arr[j] &gt; key &#123; j-- &#125; if i &lt;= j &#123; arr[i], arr[j] = arr[j], arr[i] i++ j-- &#125; &#125; if start &lt; j &#123; quickZsort(arr, start, j) &#125; if end &gt; i &#123; quickZsort(arr, i, end) &#125; &#125;&#125; Go实现插入排序 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,0&#125; insertSort(arr) fmt.Println(arr)&#125;func insertSort(arr []int) &#123; n := len(arr) if n &lt; 2 &#123; return &#125; for i := 1; i &lt; n; i++ &#123; for j := i; j &gt;0 &amp;&amp; arr[j] &lt; arr[j-1]; j-- &#123; arr[j], arr[j-1] = arr[j-1], arr[j] &#125; &#125;&#125; Go实现希尔排序 12345678910111213141516171819202122232425262728package mainimport \"fmt\"func main() &#123; var arr = []int&#123;9,8,7,5,3,4,6,2,1,0&#125; shellSort(arr) fmt.Println(arr)&#125;func shellSort(arr []int) &#123; n := len(arr) h := 1 //寻找合适的间隔h for h &lt; n/3 &#123; h = 3*h +1 &#125; for h &gt;= 1 &#123; for i := h; i &lt; n; i++ &#123; for j := i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j-1]; j -= h &#123; arr[j], arr[j-1] = arr[j-1], arr[j] &#125; &#125; h /= 3 &#125;&#125;","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://grooes.com/tags/go/"}]},{"title":"Go语言中的 Array, Slice和 Map","slug":"Go语言中的-Array-Slice和-Map","date":"2017-09-17T12:51:23.000Z","updated":"2017-09-17T13:31:38.101Z","comments":true,"path":"2017/09/17/Go语言中的-Array-Slice和-Map/","link":"","permalink":"http://grooes.com/2017/09/17/Go语言中的-Array-Slice和-Map/","excerpt":"","text":"Array, Slice和 Map的区别 Array 是值类型，Slice 和 Map 是引用类型。他们是有很大区别的，尤其是在参数传递的时候。 Slice 和 Map 的变量 仅仅声明是不行的，必须还要分配空间（也就是初始化，initialization） 才可以使用。 Slice 和 Map 这些引用变量 的 内存分配，不需要你操心，因为 golang 是存在 gc 机制的（垃圾回收机制） Array 的用法 数组的声明（这里就是定义，给数据存储分配了空间） 1var arrayName [arraySize] dataType 如果数组定义好之后， 没有给数组元素指定值，那么所有元素被自动初始化为零值 数组的初始化 12345var a = [10]int&#123;1,2,3,4,5,6,7,8,9,10&#125; //定义数组的时候，直接初始化var b = [10]int &#123;1, 2, 3, 4&#125; //部分元素初始化， 其余元素零值var c = [...]int &#123;1, 2, 3, 4, 5&#125; //由初始化列表决定数组长度，不可省去标识符 \"...\"，否则将变成切片Slicevar d = [10]&#123;2:4, 5:7&#125; //可以按照下标来进行初始化 数组的访问，可以直接按照下标进行访问 数组的遍历(for) 12345678910111213141516package mainimport( \"fmt\")func main() &#123; var f = [20]int &#123;1, 1&#125; for i := 2; i &lt; 20; i++ &#123; f[i] = f[i-1] + f[i-2] &#125; for i := 0; i &lt; 20; i++ &#123; //采用下标进行遍历 if i % 5 == 0 &#123; fmt.Printf(\"\\n\") &#125; fmt.Printf(\"f[%2d] = %4d\",i , f[i]) &#125;&#125; 数组的遍历(range) 12345678910111213package mainimport( \"fmt\")func main() &#123; var f = [20]int &#123;1, 1&#125; for i := 2; i &lt; 20; i++ &#123; f[i] = f[i-1] + f[i -2] &#125; for i , v := range f &#123; //采用 range 关键字 进行遍历 fmt.Printf(\"f[%2d] = %4d\", i, v) &#125;&#125; 多维数组 12var a [3][4]intvar b = [3][4]int &#123;&#123;1,2&#125;, &#123;1,2,3,4&#125;, &#123;2,3, 4&#125;&#125; 多维数组遍历 123456789101112131415161718package mainimport \"fmt\"func main() &#123; //找到二维数组中的最大元素 var i, j, row, col, max int var a = [3][4]int &#123;&#123;1, 3, 7, 3&#125;, &#123;2, 3, 7 , 9&#125;, &#123;22, 3, 5, 10&#125;&#125; max = a[0][0] for i := 0; i &lt; = 2; i ++ &#123; for j := 0; j &lt;= 3; j++ &#123; if a[i][j] &gt; max &#123; max = a[i][j] row = i col = j &#125; &#125; &#125; fmt.Println(\"max = %d, row = %d, col = %d\\n\", max, row, col)&#125; Slice 的用法 Slice 的声明（没有分配内存） 1var s1 []int 在创建切片的时候，不要指定切片的长度。（否则就成了数组） 切片的类型可以是Go 语言的任何基本数据类型（也包括 引用类型和 Struct 类型） 当一个切片被声明之后，没有初始化的时候，这个 s1 默认的值是 nil。切片的长度是0。可以使用内建函数 len() 获得切片的长度，使用内建函数 cap() 获得切片的容量。 Slice 的创建 (分配了内存) 三种创建方式： 基于底层数组创建，直接创建，或者 make() 函数创建 基于底层数组创建 slice 123456var slice1 []int //声明但是不分配空间slice1 = array[start:end] //这里不包含 endslice2 := array[:] // 引用全部的元素slice3 := array[0:len(array)]var slice4 []intsliec34 = array //引用全部的元素 直接创建 slice(在声明的时候，直接初始化。) 1var slice1 = []int &#123;1 ,2, 3, 4, 5&#125; make() 函数创建 slice 12var slice1 = make([]int, 5) //长度和容量都是 5var slice2 = make([]int, 5, 10) //容量是5. Slice 的 访问和遍历(采用下标进行访问，采用 range 进行遍历。) 1234567891011121314packge mainimport \"fmt\"func main() &#123; var slice1 = []int &#123;1, 2,3 , 4, 5&#125; //使用下标访问 slice for i := 0; i &lt;=4; i++ &#123; fmt.Println(\"slice[%d] = %d\", i, slice[i]) &#125; fmt.Println() //使用range 进行遍历 for i, v := range slice &#123; fmt.Println(\"slice[%d] = %d\", i, v) &#125; &#125; Slice 的操作 Slice 中的切片的元素，可以动态的添加和删除，所以操作起来要比数组更加方便 采用内建函数 append() 向切片尾部，增加新的元素， 这些元素保存到底层的数组。 append() 并不会影响原来的切片的属性，（原来切片的长度和cap） append() 将会返回更新后的切片的对象。 append() 是个变参函数，可以一次性添加多个对象 append() 添加元素的个数超过 切片的 cap() 的时候，那么底层会 重新分配一个 “足够大” 的内存，一般来说是将原来的内存空间扩大二倍，然后将数据复制到新的内存中去， 原来的空间会保留 （供原先切片使用）（底层数组变化这个问题，应该关注一下） 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; //使用make 创建 切片 var slice1 = make([]int, 3, 6) // 使用 append 添加元素，并且未超出 cap slice2 := append(slice1, 1, 2, 3) // 使用 append 添加元素，并且超出 cap. 这个时候底层数组会变化，新增加的元素只会添加到新的底层数组，不会覆盖旧的底层数组。 slice3 := append(slice1, 4, 5, 6, 7) slice1[0] = 10 fmt.Printf(\"len = %d cap = %d %v\\n\", len(slice1), cap(slice1), slice1) fmt.Printf(\"len = %d cap = %d %v\\n\", len(slice2), cap(slice2), slice2) fmt.Printf(\"len = %d cap = %d %v\\n\", len(slice3), cap(slice3), slice3)&#125;程序输出是：len = 3 cap = 6 [10 0 0]len = 6 cap = 6 [10 0 0 1 2 3] // 这里的[1, 2, 3] 没有被 [4, 5, 6]覆盖len = 7 cap = 12 [0 0 0 4 5 6 7] //这里第一个元素没有变成10，并且容量变成原来的2倍。 切片元素的复制 使用切片长时间引用超大的底层数组，会导致严重的内存浪费现象。 可以新建一个小的slice 对象，然后将所需要的数据复制过去，这样子就不会引用底层数组，直接拷贝了数据，这就是需求。函数 copy()可以 在切片之间复制元素。 copy() 可以复制的元素数量取决于 复制方 和 被复制方的最小长度。 同一个底层数组之间的 元素复制，会导致元素重叠问题。12345678910111213141516171819package mainimport \"fmt\"func main() &#123; var slice1 = []int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; var slice2 = make([]int, 3, 5) var n int n = copy(slice2, slice1) // just copy three elements fmt.Println(n, slice2, len(slice2), cap(slice2)) slice3 := slice1[3:6] //二者引用同一个底层数组 n = copy(slice3, slice1[1:5]) //所以，copy的时候发生元素重叠 fmt.Println(n, slice1, slice3)&#125;程序输出为：3 [1 2 3] 3 53 [1 2 3 2 3 4 7 8 9 10] [2 3 4] //可以看到元素重叠 Map 的用法map 存储的是 键值对(key-value)。是一个无序的数据的集合，通过键来进行索引得到对应的值。 这种方式可以加快查找速度。Map 通常称为 字典（dictionary） 或者哈希表(Hash table)。Map 现在是很多语言的标配。 字典的声明 字典名称，“键”类型， “值”类型 不需要给字典指定长度，字典的长度会在初始化或者创建的过程中动态增长 Key 必须是能支持 比较运算符（==, !=）的数据类型，比如 整数，浮点数，指针，数组，结构体，接口等。 而不能是 函数，字典，切片这些类型。 Value 类型 可以是Go语言的任何基本数据类型。1var mapName map[keyType]valueType 字典的初始化 和 创建 字典 声明好之后，必须经过初始化或者创建 才能使用。未初始化或者创建的字典为 nil 可以使用“{}”来在声明的时候进行初始化 可是使用 make()来创建字典 创建或者初始化之后，就可以使用 “=”操作符来动态的向字典中添加数据项了1234567891011var map1 map[string]int &#123;&#125; //字典的初始化map1[\"key1\"] = 1var map2 map[string]intmap2 = make(map[string]int) //字典的创建map2[\"key2\"] = 2 //使用 等号 添加数据项var map3 map[string]intmap3[\"key1\"] = 2 //编译不通过，字典没有初始化或者创建v, OK := mapName[Key] //元素的查找 注意这里是 := 12345678910111213141516171819202122232425package mainimport \"fmt\"func main() &#123; var map1 = map[string]int&#123;\"key1\": 100, \"key2\": 200&#125; // v, OK := map1[\"key1\"] if OK &#123; fmt.Println(v, OK) &#125; else &#123; fmt.Println(v) &#125; // 这里 不是 :=，是 = ，因为这些变量已经定义过了。 v, OK = map1[\"key3\"] if OK &#123; fmt.Println(v, OK) &#125; else &#123; fmt.Println(v) &#125;&#125;输出为：100 true0 字典项的删除 go 提供了内置函数 delete() 来删除容器内的元素。(如果key1值不存在，那么调用将什么也不发生，也不会产生副作用。 但是，如果传入的map 是一个 nil，那么将导致程序出现异常，这一点在写程序的时候特别注意。)1delete(map1, \"key1\") 12345678910111213141516171819202122232425package mainimport ( \"fmt\")func main() &#123; var map1 = map[string]int&#123;\"key1\": 100, \"key2\": 200, \"key3\": 300&#125; for k, v := range map1 &#123; fmt.Println(k, v) if k == \"key2\" &#123; delete(map1, k) &#125; if k == \"key3\" &#123; map1[\"key4\"] = 400 &#125; &#125; fmt.Println(map1)&#125;程序输出：key2 200key3 300key1 100map[key1:100 key4:400 key3:300] //可以看到 map 是无序的。","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://grooes.com/tags/go/"}]},{"title":"mysql安装那点事儿","slug":"mysql安装那点事儿","date":"2017-09-17T09:02:24.000Z","updated":"2017-09-17T09:03:35.251Z","comments":true,"path":"2017/09/17/mysql安装那点事儿/","link":"","permalink":"http://grooes.com/2017/09/17/mysql安装那点事儿/","excerpt":"","text":"安装mysql rpm -qa | grep mysql // 这个命令就会查看该操作系统上是否已经安装了mysql数据库rpm -e mysql // 普通删除模式rpm -e –nodeps mysql // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除yum list | grep mysql //查看yum上提供的mysql数据库可下载的版本yum install -y mysql-server mysql mysql-deve //下载rpm -qi mysql-server //查看mysql版本service mysqld start //启动mysqlservice mysqld restart //重启mysqlchkconfig –list | grep mysqld //查看mysql服务是不是开机自动启动mysqld 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭chkconfig mysqld on //设置成开机启动，这样就不用每次都去手动启动了/usr/bin/mysqladmin -u root password ‘root’ //设置账号密码mysql -u root -p //进入mysql数据库Enter password: //输入密码即可完毕！ centos6.6安装mysql5.7.17 因用yum安装的是比较古老的mysql版本，所以需要升级最新版本首先查看安装的mysql，需要全部移除rpm -qa | grep mysqlmysql-community-common-5.1.17-1.el6.x86_64mysql-community-libs-5.2.17-1.el6.x86_64mysql-community-server-5.1.17-1.el6.x86_64mysql-community-client-5.1.17-1.el6.x86_64一共四个需要全部删除rpm -e –nodeps mysql-community-common-5.1.17-1.el6.x86_64rpm -e –nodeps mysql-community-libs-5.2.17-1.el6.x86_64rpm -e –nodeps mysql-community-server-5.1.17-1.el6.x86_64rpm -e –nodeps mysql-community-client-5.1.17-1.el6.x86_64rpm -qa | grep mysql确保没有了mysql 进入：https://dev.mysql.com/downloads/file/?id=467446下载到的包：mysql-5.7.17-1.el6.x86_64.rpm-bundle.tarcd /tmprz mysql-5.7.17-1.el6.x86_64.rpm-bundle.tartar -xvf mysql-5.7.17-1.el6.x86_64.rpm-bundle.tarrpm -ivh mysql-community-common-5.7.17-1.el6.x86_64.rpmrpm -ivh mysql-community-libs-5.7.17-1.el6.x86_64.rpmrpm -ivh mysql-community-client-5.7.17-1.el6.x86_64.rpmrpm -ivh mysql-community-server-5.7.17-1.el6.x86_64.rpmchmod 777 -R /var/lib/mysqlservice mysqld startMySQL Daemon failed to start.正在启动 mysqld： [失败]getenforceEnforcingsetenforce 0service mysqld start正在启动 mysqld： [确定]mysqlERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)尼玛，我怎么知道密码？我都没设置密码shell&gt;/usr/bin/mysqld_safe –skip-grant-tables &amp;shell&gt;mysql -u root -p下面的密码直接键入回车即可.mysql&gt;use mysqlmysql&gt;update mysql.user set authentication_string=PASSWORD(‘root’) where user=’root’ and host=’localhost’;mysql&gt;flush privileges;mysql&gt;exit;shell&gt;mysql -u root -p输入密码即可完毕！突然发现在关闭服务器后去启动mysql的时候又启动失败了猜想是getenforce，于是乎执行getenforce竟然成了Enforcing，如果每次启动都这样，岂不是很累，于是乎不能忍google了下，永久解决办法是设置永久性的shell&gt;vi /etc/sysconfig/selinuxSELINUX=disabled 设置成这样既可，打开是知道共有三个值可以选择的done!然后进入shell&gt;mysql -u root -p输入密码后执行mysql&gt;show databases;ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.错误解决办法：mysql&gt;SET PASSWORD= PASSWORD(‘new password’);mysql&gt;ALTER USER ‘root’@’localhost’ PASSWORD EXPIRE NEVER;mysql&gt;flush privileges;mysql&gt;exit;重新登录既可done!","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://grooes.com/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"http://grooes.com/tags/mysql/"}]},{"title":"PHP7环境搭建那点事儿","slug":"PHP7环境搭建那点事儿","date":"2017-09-17T01:30:09.000Z","updated":"2017-09-17T02:16:26.950Z","comments":true,"path":"2017/09/17/PHP7环境搭建那点事儿/","link":"","permalink":"http://grooes.com/2017/09/17/PHP7环境搭建那点事儿/","excerpt":"","text":"安装包准备 nginx-1.11.6.tar.gz google-perftools-1.6.tar.gz libevent-2.0.22-stable.tar.gz libiconv-1.13.1.tar.gz libmcrypt-2.5.8.tar.gz libmemcached-1.0.18.tar.gz m9php-php7.tar.gz mcrypt-2.6.8.tar.gz memcache-3.0.8.tgz memcached-1.4.34.tar.gz mhash-0.9.9.9.tar.gz pecl-memcache-php7.tar.gz php-7.0.14.tar.gz php-memcached-master.tar.gz phpredis-develop.tar.gz protobuf-master.tar.gz 环境准备 yum -y install lrzsz（为了运用rz命令把本地包上次上去） yum -y install wget(为了下载包) yum -y install zip unzip(为了解压包) yum -y install gcc(安装gcc) yum -y install openssl openssl-devel(安装openssl) yum -y install pcre*(安装pcre) yum -y install gcc gcc-c++(安装c++) yum -y install libxml2(安装相关libxml2) yum -y install curl(安装curl相关) yum -y install curl-devel(安装curl-devel) yum -y install libpng*(安装libpng相关) 相关环境搭建 安装nginx tar zxf nginx-1.11.6.tar.gzcd nginx-1.11.6./configure –prefix=/usr/local/nginx –user=www –group=www –with-http_stub_status_module –with-http_flv_module –with-http_ssl_modulemake &amp;&amp; make install 启动nginx /usr/local/nginx/sbin/nginx报错：nginx: [emerg] getpwnam(“www”) failed解决方式1：在nginx.conf中 把user nobody的注释去掉既可解决方式2：/usr/sbin/groupadd -f www /usr/sbin/useradd -g www www 本机浏览器输入：http://ip/成功标识：Welcome to nginx!失败标识：考虑关闭防火墙或者打开80端口即可 安装libiconv tar zxf libiconv-1.13.1.tar.gzcd libiconv-1.13.1/./configure –prefix=/usr/local/libiconvmake &amp;&amp; make install 安装libevent tar zxvf libevent-2.0.22-stable.tar.gz cd libevent-2.0.22-stable./configure –prefix=/usr/local/libeventmake &amp;&amp; make test &amp;&amp; make install 安装libmcrypt tar zxf libmcrypt-2.5.8.tar.gzcd libmcrypt-2.5.8/./configuremake &amp;&amp; make install 安装mhash tar zxf mhash-0.9.9.9.tar.gzcd mhash-0.9.9.9./configuremake &amp;&amp; make install 开启软连接 ln -s /usr/local/lib/libmcrypt.la /usr/lib/libmcrypt.laln -s /usr/local/lib/libmcrypt.so /usr/lib/libmcrypt.soln -s /usr/local/lib/libmcrypt.so.4 /usr/lib/libmcrypt.so.4ln -s /usr/local/lib/libmcrypt.so.4.4.8 /usr/lib/libmcrypt.so.4.4.8ln -s /usr/local/lib/libmhash.a /usr/lib/libmhash.aln -s /usr/local/lib/libmhash.la /usr/lib/libmhash.laln -s /usr/local/lib/libmhash.so /usr/lib/libmhash.soln -s /usr/local/lib/libmhash.so.2 /usr/lib/libmhash.so.2ln -s /usr/local/lib/libmhash.so.2.0.1 /usr/lib/libmhash.so.2.0.1ln -s /usr/local/bin/libmcrypt-config /usr/bin/libmcrypt-config 安装memcached tar -zxvf memcached-1.4.34.tar.gzcd memcached-1.4.34./configure –prefix=/usr/local/memcached –with-libevent=/usr/local/libevent/make &amp;&amp; make install启动memcached :/usr/local/memcached/bin/memcached -d -m 100 -u root -l 127.0.0.1 -p 11211 -c 256 -P /tmp/memcached.pid 安装mcrypt tar zvxf mcrypt-2.6.8.tar.gzcd mcrypt-2.6.8./configure报错：configure: error: * libmcrypt was not found （其实我已经安装了libmcrypt）解决：export LD_LIBRARY_PATH=/usr/local/lib: LD_LIBRARY_PATH./configuremake &amp;&amp; make install 安装php7 tar zvxf php-7.0.14.tar.gzcd php-7.0.14./configure –prefix=/usr/local/php –with-config-file-path=/usr/local/php/etc –enable-fpm –enable-pcntl –enable-mysqlnd –enable-opcache –enable-sockets –enable-sysvmsg –enable-sysvsem –enable-sysvshm –enable-shmop –enable-zip –enable-ftp –enable-soap –enable-xml –enable-mbstring –disable-rpath –disable-debug –disable-fileinfo –with-mysqli –with-pdo-mysql –with-pcre-regex –with-iconv –with-zlib –with-mcrypt –with-gd –with-openssl –with-mhash –with-xmlrpc –with-curl –without-pear –enable-fileinfo –with-imap-sslmake &amp;&amp; make installcp ./php.ini-development /usr/local/php/etc/php.inicp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.confcp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.confcp -R ./sapi/fpm/php-fpm /etc/init.d/php-fpm 安装libmemcached tar zxvf libmemcached-1.0.18.tar.gzcd libmemcached-1.0.18./configure –prefix=/usr/local/libmemcached –with-memcachedmake &amp;&amp; make install 安装php-memcached扩展 tar xvzf php-memcached-master.tar.gzcd php-memcached-master/usr/local/php/bin/phpize./configure –enable-memcached –with-php-config=/usr/local/php/bin/php-config –with-libmemcached-dir=/usr/local/libmemcached –disable-memcached-saslmake &amp;&amp; make install查看是否安装成功/usr/local/php/bin/php -m 测试php-memcached扩展 vi /usr/local/php/etc/php.ini添加：extension=memcached.so wq!启动fpm:/usr/local/php/sbin/php-fpm -R验证：ps -ef | grep ‘fpm’启动memcached:/usr/local/memcached/bin/memcached -d -m 100 -u root -l 127.0.0.1 -p 11211 -c 256 -P /tmp/memcached.pid验证：ps -ef | grep ‘memcached’验证是否连接成功vi /tmp/memcached.php输入：12345678910111213&lt;?php $m = new Memcached(); $m-&gt;addServer('127.0.0.1', 11211); $m-&gt;set('int', 99); $m-&gt;set('string', 'a simple string'); $m-&gt;set('array', array(11, 12)); $m-&gt;set('object', new stdclass, time() + 300); var_dump($m-&gt;get('int')); var_dump($m-&gt;get('string')); var_dump($m-&gt;get('array')); var_dump($m-&gt;get('object'));?&gt; wq!cd /tmp执行：/usr/local/php/bin/php memcached.php 打印成功即可 测试php-mysql扩展 vi /tmp/mysql.php1234567&lt;?php $pdo = new PDO(\"mysql:host=hostname;dbname=databasename\",\"root\",\"\"); $rs = $pdo -&gt; query(\"select * from test\"); while($row = $rs -&gt; fetch())&#123; print_r($row); &#125;?&gt; wq!cd /tmp执行：/usr/local/php/bin/php mysql.php 打印成功即可 安装php-redis扩展 tar xvf phpredis-develop.tar.gzcd phpredis-develop/usr/local/php/bin/phpize./configure –with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make installvi /usr/local/php/etc/php.ini输入：extension=redis.sowq!查看是否安装成功/usr/local/php/bin/php -m 安装m9php-php7扩展 tar -zxvf m9php-php7.tar.gzcd m9php/m9php/usr/local/php/bin/phpize./configure –with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make installvi /usr/local/php/etc/php.ini输入：extension=m9php.sowq!查看是否安装成功/usr/local/php/bin/php -m","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://grooes.com/tags/php/"},{"name":"linux","slug":"linux","permalink":"http://grooes.com/tags/linux/"}]}]}